import{j as Se}from"./jsx-runtime.QxmL55Mq.js";import{d as C,R as an}from"./server.browser.D4hb9_uX.js";var Ss=Object.defineProperty,Ts=(t,e)=>{for(var n in e)Ss(t,n,{get:e[n],enumerable:!0})},Is="@liveblocks/core",cn="2.1.0",Os="esm",xe=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:{},ks="https://liveblocks.io/docs/errors/dupes",As=" ";function Cs(t){console.error(t)}function Ve(t,e,n){const s=Symbol.for(t),r=`${e} (${n})`;if(!xe[s])xe[s]=r;else if(xe[s]!==r){const i=[`Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${ks+As}`,"","Conflicts:",`- ${t} ${xe[s]} (already loaded)`,`- ${t} ${r} (trying to load this now)`].join(`
`);Cs(i)}}function X(t,e){throw new Error(e)}function k(t,e="Expected value to be non-nullable"){return t}function un(){let t,e;return[new Promise((s,r)=>{t=s,e=r}),t,e]}function Ps(){const[t,e,n]=un();return{promise:t,resolve:e,reject:n}}function P(){const t=new Set,e=new Set;let n=null;function s(){n=[]}function r(){if(n!==null){for(const g of n)d(g);n=null}}function i(g){return e.add(g),()=>e.delete(g)}function a(g){return t.add(g),()=>t.delete(g)}async function c(g){let E;return new Promise(w=>{E=i(y=>{(g===void 0||g(y))&&w(y)})}).finally(()=>E==null?void 0:E())}function o(g){n!==null?n.push(g):d(g)}function d(g){t.forEach(E=>E(g)),t.clear(),e.forEach(E=>E(g))}function m(){t.clear(),e.clear()}function _(){return t.size+e.size}return{notify:o,subscribe:i,subscribeOnce:a,clear:m,count:_,waitUntil:c,pause:s,unpause:r,observable:{subscribe:i,subscribeOnce:a,waitUntil:c}}}var _t={};Ts(_t,{error:()=>fn,errorWithTitle:()=>pn,warn:()=>B,warnWithTitle:()=>Rs});var dn="background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;",Ns="font-weight:600";function ln(t){return typeof window>"u"?console[t]:(e,...n)=>console[t]("%cLiveblocks",dn,e,...n)}var B=ln("warn"),fn=ln("error");function hn(t){return typeof window>"u"?console[t]:(e,n,...s)=>console[t](`%cLiveblocks%c ${e}`,dn,Ns,n,...s)}var Rs=hn("warn"),pn=hn("error");function Ds(t,e){if(t===e)return[0,0];const n=t.split("."),s=e.split("."),r=Math.min(n.length,s.length);let i=0;for(;i<r&&n[i]===s[i];i++);const a=n.length-i,c=s.length-i;return[a,c]}function Ls(t,e){const n=t.split(".");if(e<1||e>n.length+1)throw new Error("Invalid number of levels");const s=[];e>n.length&&s.push("*");for(let r=n.length-e+1;r<n.length;r++){const i=n.slice(0,r);i.length>0&&s.push(i.join(".")+".*")}return s.push(t),s}var xs=class{constructor(t){this.curr=t}get current(){return this.curr}allowPatching(t){const e=this;let n=!0;const s={...this.curr,patch(r){if(n){e.curr=Object.assign({},e.curr,r);for(const i of Object.entries(r)){const[a,c]=i;a!=="patch"&&(this[a]=c)}}else throw new Error("Can no longer patch stale context")}};t(s),n=!1}},Us=1,Ms=class{get initialState(){const t=this.states.values()[Symbol.iterator]().next();if(t.done)throw new Error("No states defined yet");return t.value}get currentState(){if(this.currentStateOrNull===null)throw this.runningState===0?new Error("Not started yet"):new Error("Already stopped");return this.currentStateOrNull}start(){if(this.runningState!==0)throw new Error("State machine has already started");return this.runningState=1,this.currentStateOrNull=this.initialState,this.enter(null),this}stop(){if(this.runningState!==1)throw new Error("Cannot stop a state machine that hasn't started yet");this.exit(null),this.runningState=2,this.currentStateOrNull=null}constructor(t){this.id=Us++,this.runningState=0,this.currentStateOrNull=null,this.states=new Set,this.enterFns=new Map,this.cleanupStack=[],this.knownEventTypes=new Set,this.allowedTransitions=new Map,this.currentContext=new xs(t),this.eventHub={didReceiveEvent:P(),willTransition:P(),didIgnoreEvent:P(),willExitState:P(),didEnterState:P()},this.events={didReceiveEvent:this.eventHub.didReceiveEvent.observable,willTransition:this.eventHub.willTransition.observable,didIgnoreEvent:this.eventHub.didIgnoreEvent.observable,willExitState:this.eventHub.willExitState.observable,didEnterState:this.eventHub.didEnterState.observable}}get context(){return this.currentContext.current}addState(t){if(this.runningState!==0)throw new Error("Already started");return this.states.add(t),this}onEnter(t,e){if(this.runningState!==0)throw new Error("Already started");if(this.enterFns.has(t))throw new Error(`enter/exit function for ${t} already exists`);return this.enterFns.set(t,e),this}onEnterAsync(t,e,n,s){return this.onEnter(t,()=>{const r=new AbortController,i=r.signal;let a=!1;return e(this.currentContext.current,i).then(c=>{i.aborted||(a=!0,this.transition({type:"ASYNC_OK",data:c},n))},c=>{i.aborted||(a=!0,this.transition({type:"ASYNC_ERROR",reason:c},s))}),()=>{a||r.abort()}})}getStatesMatching(t){const e=[];if(t==="*")for(const n of this.states)e.push(n);else if(t.endsWith(".*")){const n=t.slice(0,-1);for(const s of this.states)s.startsWith(n)&&e.push(s)}else{const n=t;this.states.has(n)&&e.push(n)}if(e.length===0)throw new Error(`No states match ${JSON.stringify(t)}`);return e}addTransitions(t,e){if(this.runningState!==0)throw new Error("Already started");for(const n of this.getStatesMatching(t)){let s=this.allowedTransitions.get(n);s===void 0&&(s=new Map,this.allowedTransitions.set(n,s));for(const[r,i]of Object.entries(e)){if(s.has(r))throw new Error(`Trying to set transition "${r}" on "${n}" (via "${t}"), but a transition already exists there.`);const a=i;if(this.knownEventTypes.add(r),a!==void 0){const c=typeof a=="function"?a:()=>a;s.set(r,c)}}}return this}addTimedTransition(t,e,n){return this.onEnter(t,()=>{const s=typeof e=="function"?e(this.currentContext.current):e,r=setTimeout(()=>{this.transition({type:"TIMER"},n)},s);return()=>{clearTimeout(r)}})}getTargetFn(t){var e;return(e=this.allowedTransitions.get(this.currentState))==null?void 0:e.get(t)}exit(t){this.eventHub.willExitState.notify(this.currentState),this.currentContext.allowPatching(e=>{var n;t=t??this.cleanupStack.length;for(let s=0;s<t;s++)(n=this.cleanupStack.pop())==null||n(e)})}enter(t){const e=Ls(this.currentState,t??this.currentState.split(".").length+1);this.currentContext.allowPatching(n=>{for(const s of e){const r=this.enterFns.get(s),i=r==null?void 0:r(n);typeof i=="function"?this.cleanupStack.push(i):this.cleanupStack.push(null)}}),this.eventHub.didEnterState.notify(this.currentState)}send(t){if(!this.knownEventTypes.has(t.type))throw new Error(`Invalid event ${JSON.stringify(t.type)}`);if(this.runningState===2)return;const e=this.getTargetFn(t.type);if(e!==void 0)return this.transition(t,e);this.eventHub.didIgnoreEvent.notify(t)}transition(t,e){this.eventHub.didReceiveEvent.notify(t);const n=this.currentState,r=(typeof e=="function"?e:()=>e)(t,this.currentContext.current);let i,a;if(r===null){this.eventHub.didIgnoreEvent.notify(t);return}if(typeof r=="string"?i=r:(i=r.target,a=Array.isArray(r.effect)?r.effect:[r.effect]),!this.states.has(i))throw new Error(`Invalid next state name: ${JSON.stringify(i)}`);this.eventHub.willTransition.notify({from:n,to:i});const[c,o]=Ds(this.currentState,i);if(c>0&&this.exit(c),this.currentStateOrNull=i,a!==void 0){const d=a;this.currentContext.allowPatching(m=>{for(const _ of d)typeof _=="function"?_(m,t):m.patch(_)})}o>0&&this.enter(o)}};function $s(t){throw new Error(t)}function mn(t){return t!==null&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"}function _n(t){return Object.entries(t)}function yt(t){try{return JSON.parse(t)}catch{return}}function Te(t){return JSON.parse(JSON.stringify(t))}function js(t){try{const e=t.replace(/-/g,"+").replace(/_/g,"/");return decodeURIComponent(atob(e).split("").map(function(s){return"%"+("00"+s.charCodeAt(0).toString(16)).slice(-2)}).join(""))}catch{return atob(t)}}function ot(t){return t.filter(e=>e!=null)}function ze(t){const e={...t};return Object.keys(t).forEach(n=>{const s=n;e[s]===void 0&&delete e[s]}),e}async function Mt(t,e,n){let s;const r=new Promise((i,a)=>{s=setTimeout(()=>{a(new Error(n))},e)});return Promise.race([t,r]).finally(()=>clearTimeout(s))}function $t(t){let e=null;return()=>(e===null&&(e={value:t()}),e.value)}var te=(t=>(t[t.UPDATE_PRESENCE=100]="UPDATE_PRESENCE",t[t.USER_JOINED=101]="USER_JOINED",t[t.USER_LEFT=102]="USER_LEFT",t[t.BROADCASTED_EVENT=103]="BROADCASTED_EVENT",t[t.ROOM_STATE=104]="ROOM_STATE",t[t.INITIAL_STORAGE_STATE=200]="INITIAL_STORAGE_STATE",t[t.UPDATE_STORAGE=201]="UPDATE_STORAGE",t[t.REJECT_STORAGE_OP=299]="REJECT_STORAGE_OP",t[t.UPDATE_YDOC=300]="UPDATE_YDOC",t[t.THREAD_CREATED=400]="THREAD_CREATED",t[t.THREAD_DELETED=407]="THREAD_DELETED",t[t.THREAD_METADATA_UPDATED=401]="THREAD_METADATA_UPDATED",t[t.COMMENT_CREATED=402]="COMMENT_CREATED",t[t.COMMENT_EDITED=403]="COMMENT_EDITED",t[t.COMMENT_DELETED=404]="COMMENT_DELETED",t[t.COMMENT_REACTION_ADDED=405]="COMMENT_REACTION_ADDED",t[t.COMMENT_REACTION_REMOVED=406]="COMMENT_REACTION_REMOVED",t))(te||{});function jt(t){return t===4999||t>=4e3&&t<4100}function Ks(t){return t>=4100&&t<4200}function Kt(t){return t===1013||t>=4200&&t<4300}function Fs(t){return t==="initial"||t==="disconnected"}function yn(t){const e=t.currentState;switch(e){case"@ok.connected":case"@ok.awaiting-pong":return"connected";case"@idle.initial":return"initial";case"@auth.busy":case"@auth.backoff":case"@connecting.busy":case"@connecting.backoff":case"@idle.zombie":return t.context.successCount>0?"reconnecting":"connecting";case"@idle.failed":return"disconnected";default:return X(e,"Unknown state")}}var vn=[250,500,1e3,2e3,4e3,8e3,1e4],Ue=vn[0]-1,Hs=[2e3,3e4,6e4,3e5],Vs=3e4,zs=2e3,Ws=1e4,Bs=1e4,ie=class extends Error{constructor(t){super(t)}},Js=class extends Error{constructor(t,e){super(t),this.code=e}};function gn(t,e){return e.find(n=>n>t)??e[e.length-1]}function le(t){t.patch({backoffDelay:gn(t.backoffDelay,vn)})}function Ft(t){t.patch({backoffDelay:gn(t.backoffDelay,Hs)})}function Ht(t){t.patch({successCount:0})}function he(t,e){const n=t===2?fn:t===1?B:()=>{};return()=>{n(e)}}function Vt(t){const e="Connection to Liveblocks websocket server";return n=>{t instanceof Error?B(`${e} could not be established. ${String(t)}`):B(bn(t)?`${e} closed prematurely (code: ${t.code}). Retrying in ${n.backoffDelay}ms.`:`${e} could not be established.`)}}function et(t){const e=[`code: ${t.code}`];return t.reason&&e.push(`reason: ${t.reason}`),n=>{B(`Connection to Liveblocks websocket server closed (${e.join(", ")}). Retrying in ${n.backoffDelay}ms.`)}}var Gs=he(1,"Connection to WebSocket closed permanently. Won't retry.");function bn(t){return!(t instanceof Error)&&t.type==="close"}function Ys(t){const e=new Date().getTime();function n(...r){B(`${((new Date().getTime()-e)/1e3).toFixed(2)} [FSM #${t.id}]`,...r)}const s=[t.events.didReceiveEvent.subscribe(r=>n(`Event ${r.type}`)),t.events.willTransition.subscribe(({from:r,to:i})=>n("Transitioning",r,"→",i)),t.events.didIgnoreEvent.subscribe(r=>n("Ignored event",r.type,r,"(current state won't handle it)"))];return()=>{for(const r of s)r()}}function qs(t){const e=P(),n=P(),s=P();let r=null;const i=t.events.didEnterState.subscribe(()=>{const a=yn(t);a!==r&&e.notify(a),r==="connected"&&a!=="connected"?s.notify():r!=="connected"&&a==="connected"&&n.notify(),r=a});return{statusDidChange:e.observable,didConnect:n.observable,didDisconnect:s.observable,unsubscribe:i}}var Me=t=>e=>e.patch(t);function Xs(t,e){const n=P();n.pause();const s=P();function r(f,h){return()=>{const T=new Js(f,h);s.notify(T)}}const i={successCount:0,authValue:null,socket:null,backoffDelay:Ue},a=new Ms(i).addState("@idle.initial").addState("@idle.failed").addState("@idle.zombie").addState("@auth.busy").addState("@auth.backoff").addState("@connecting.busy").addState("@connecting.backoff").addState("@ok.connected").addState("@ok.awaiting-pong");a.addTransitions("*",{RECONNECT:{target:"@auth.backoff",effect:[le,Ht]},DISCONNECT:"@idle.initial"}),a.onEnter("@idle.*",Ht).addTransitions("@idle.*",{CONNECT:(f,h)=>h.authValue!==null?"@connecting.busy":"@auth.busy"}),a.addTransitions("@auth.backoff",{NAVIGATOR_ONLINE:{target:"@auth.busy",effect:Me({backoffDelay:Ue})}}).addTimedTransition("@auth.backoff",f=>f.backoffDelay,"@auth.busy").onEnterAsync("@auth.busy",()=>Mt(t.authenticate(),Ws,"Timed out during auth"),f=>({target:"@connecting.busy",effect:Me({authValue:f.data})}),f=>f.reason instanceof ie?{target:"@idle.failed",effect:[he(2,f.reason.message),r(f.reason.message,-1)]}:{target:"@auth.backoff",effect:[le,he(2,`Authentication failed: ${f.reason instanceof Error?f.reason.message:String(f.reason)}`)]});const c=f=>a.send({type:"EXPLICIT_SOCKET_ERROR",event:f}),o=f=>a.send({type:"EXPLICIT_SOCKET_CLOSE",event:f}),d=f=>f.data==="pong"?a.send({type:"PONG"}):n.notify(f);function m(f){f&&(f.removeEventListener("error",c),f.removeEventListener("close",o),f.removeEventListener("message",d),f.close())}a.addTransitions("@connecting.backoff",{NAVIGATOR_ONLINE:{target:"@connecting.busy",effect:Me({backoffDelay:Ue})}}).addTimedTransition("@connecting.backoff",f=>f.backoffDelay,"@connecting.busy").onEnterAsync("@connecting.busy",async(f,h)=>{let T=null,K=null;const D=new Promise(($,G)=>{if(f.authValue===null)throw new Error("No auth authValue");const L=t.createSocket(f.authValue);K=L;function A(Y){T=Y,L.removeEventListener("message",d),G(Y)}const[R,U]=un();e.waitForActorId||U();function M(Y){const se=yt(Y.data);(se==null?void 0:se.type)===104&&U()}L.addEventListener("message",d),e.waitForActorId&&L.addEventListener("message",M),L.addEventListener("error",A),L.addEventListener("close",A),L.addEventListener("open",()=>{L.addEventListener("error",c),L.addEventListener("close",o);const Y=()=>{L.removeEventListener("error",A),L.removeEventListener("close",A),L.removeEventListener("message",M)};R.then(()=>{$([L,Y])})})});return Mt(D,Bs,"Timed out during websocket connection").then(([$,G])=>{if(G(),h.aborted)throw new Error("Aborted");if(T)throw T;return $}).catch($=>{throw m(K),$})},f=>({target:"@ok.connected",effect:Me({socket:f.data,backoffDelay:Ue})}),f=>{const h=f.reason;if(h instanceof ie)return{target:"@idle.failed",effect:[he(2,h.message),r(h.message,-1)]};if(bn(h)){if(h.code===4109)return"@auth.busy";if(Kt(h.code))return{target:"@connecting.backoff",effect:[Ft,Vt(h)]};if(jt(h.code))return{target:"@idle.failed",effect:[he(2,h.reason),r(h.reason,h.code)]}}return{target:"@auth.backoff",effect:[le,Vt(h)]}});const _={target:"@ok.awaiting-pong",effect:f=>{var h;(h=f.socket)==null||h.send("ping")}},g=()=>{const f=typeof document<"u"?document:void 0;return(f==null?void 0:f.visibilityState)==="hidden"&&t.canZombie()?"@idle.zombie":_};if(a.addTimedTransition("@ok.connected",Vs,g).addTransitions("@ok.connected",{NAVIGATOR_OFFLINE:g,WINDOW_GOT_FOCUS:_}),a.addTransitions("@idle.zombie",{WINDOW_GOT_FOCUS:"@connecting.backoff"}),a.onEnter("@ok.*",f=>{f.patch({successCount:f.successCount+1});const h=setTimeout(n.unpause,0);return T=>{m(T.socket),T.patch({socket:null}),clearTimeout(h),n.pause()}}).addTransitions("@ok.awaiting-pong",{PONG:"@ok.connected"}).addTimedTransition("@ok.awaiting-pong",zs,{target:"@connecting.busy",effect:he(1,"Received no pong from server, assume implicit connection loss.")}).addTransitions("@ok.*",{EXPLICIT_SOCKET_ERROR:(f,h)=>{var T;return((T=h.socket)==null?void 0:T.readyState)===1?null:{target:"@connecting.backoff",effect:le}},EXPLICIT_SOCKET_CLOSE:f=>jt(f.event.code)?{target:"@idle.failed",effect:[Gs,r(f.event.reason,f.event.code)]}:Ks(f.event.code)?f.event.code===4109?"@auth.busy":{target:"@auth.backoff",effect:[le,et(f.event)]}:Kt(f.event.code)?{target:"@connecting.backoff",effect:[Ft,et(f.event)]}:{target:"@connecting.backoff",effect:[le,et(f.event)]}}),typeof document<"u"){const f=typeof document<"u"?document:void 0,h=typeof window<"u"?window:void 0,T=h??f;a.onEnter("*",K=>{function D(){a.send({type:"NAVIGATOR_OFFLINE"})}function $(){a.send({type:"NAVIGATOR_ONLINE"})}function G(){(f==null?void 0:f.visibilityState)==="visible"&&a.send({type:"WINDOW_GOT_FOCUS"})}return h==null||h.addEventListener("online",$),h==null||h.addEventListener("offline",D),T==null||T.addEventListener("visibilitychange",G),()=>{T==null||T.removeEventListener("visibilitychange",G),h==null||h.removeEventListener("online",$),h==null||h.removeEventListener("offline",D),m(K.socket)}})}const E=[],{statusDidChange:w,didConnect:y,didDisconnect:b,unsubscribe:S}=qs(a);return E.push(S),e.enableDebugLogging&&E.push(Ys(a)),a.start(),{machine:a,cleanups:E,events:{statusDidChange:w,didConnect:y,didDisconnect:b,onMessage:n.observable,onLiveblocksError:s.observable}}}var Qs=class{constructor(t,e=!1,n=!0){const{machine:s,events:r,cleanups:i}=Xs(t,{waitForActorId:n,enableDebugLogging:e});this.machine=s,this.events=r,this.cleanups=i}getStatus(){try{return yn(this.machine)}catch{return"initial"}}get authValue(){return this.machine.context.authValue}connect(){this.machine.send({type:"CONNECT"})}reconnect(){this.machine.send({type:"RECONNECT"})}disconnect(){this.machine.send({type:"DISCONNECT"})}destroy(){this.machine.stop();let t;for(;t=this.cleanups.pop();)t()}send(t){var n;const e=(n=this.machine.context)==null?void 0:n.socket;e===null?B("Cannot send: not connected yet",t):e.readyState!==1?B("Cannot send: WebSocket no longer open",t):e.send(t)}_privateSendMachineEvent(t){this.machine.send(t)}};function at(t){return t.includes("room:write")}function wn(t){return t.includes("comments:write")||t.includes("room:write")}function Zs(t){return mn(t)&&(t.k==="acc"||t.k==="id"||t.k==="sec-legacy")}function zt(t){const e=t.split(".");if(e.length!==3)throw new Error("Authentication error: invalid JWT token");const n=yt(js(e[1]));if(!(n&&Zs(n)))throw new Error("Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback");return{raw:t,parsed:n}}function er(t){const e=tr(t),n=new Set,s=[],r=[],i=new Map;function a(){n.clear(),s.length=0,r.length=0,i.clear()}function c(_,g){return _==="comments:read"?g.includes("comments:read")||g.includes("comments:write")||g.includes("room:read")||g.includes("room:write"):_==="room:read"?g.includes("room:read")||g.includes("room:write"):!1}function o(_){const g=Math.ceil(Date.now()/1e3);for(let E=s.length-1;E>=0;E--){const w=s[E];if(r[E]<=g){s.splice(E,1),r.splice(E,1);continue}if(w.parsed.k==="id")return w;if(w.parsed.k==="acc"){if(!_.roomId&&Object.entries(w.parsed.perms).length===0)return w;for(const[b,S]of Object.entries(w.parsed.perms))if(_.roomId){if(b.includes("*")&&_.roomId.startsWith(b.replace("*",""))||_.roomId===b&&c(_.requestedScope,S))return w}else if(b.includes("*")&&c(_.requestedScope,S))return w}}}async function d(_){var E;const g=((E=t.polyfills)==null?void 0:E.fetch)??(typeof window>"u"?void 0:window.fetch);if(e.type==="private"){if(g===void 0)throw new ie("To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.");const w=await nr(g,e.url,{room:_.roomId}),y=zt(w.token);if(n.has(y.raw))throw new ie("The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.");return y}if(e.type==="custom"){const w=await e.callback(_.roomId);if(w&&typeof w=="object"){if(typeof w.token=="string")return zt(w.token);if(typeof w.error=="string"){const y=`Authentication failed: ${"reason"in w&&typeof w.reason=="string"?w.reason:"Forbidden"}`;throw w.error==="forbidden"?new ie(y):new Error(y)}}throw new Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: "..." }')}throw new Error("Unexpected authentication type. Must be private or custom.")}async function m(_){if(e.type==="public")return{type:"public",publicApiKey:e.publicApiKey};const g=o(_);if(g!==void 0)return{type:"secret",token:g};let E;_.roomId?(E=i.get(_.roomId),E===void 0&&(E=d(_),i.set(_.roomId,E))):(E=i.get("liveblocks-user-token"),E===void 0&&(E=d(_),i.set("liveblocks-user-token",E)));try{const w=await E,b=Math.floor(Date.now()/1e3)+(w.parsed.exp-w.parsed.iat)-30;return n.add(w.raw),w.parsed.k!=="sec-legacy"&&(s.push(w),r.push(b)),{type:"secret",token:w}}finally{_.roomId?i.delete(_.roomId):i.delete("liveblocks-user-token")}}return{reset:a,getAuthValue:m}}function tr(t){const{publicApiKey:e,authEndpoint:n}=t;if(n!==void 0&&e!==void 0)throw new Error("You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient");if(typeof e=="string"){if(e.startsWith("sk_"))throw new Error("Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey");if(!e.startsWith("pk_"))throw new Error("Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey");return{type:"public",publicApiKey:e}}if(typeof n=="string")return{type:"private",url:n};if(typeof n=="function")return{type:"custom",callback:n};throw n!==void 0?new Error("The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"):new Error("Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient")}async function nr(t,e,n){const s=await t(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(!s.ok){const a=`${(await s.text()).trim()||"reason not provided in auth response"} (${s.status} returned by POST ${e})`;throw s.status===401||s.status===403?new ie(`Unauthorized: ${a}`):new Error(`Failed to authenticate: ${a}`)}let r;try{r=await s.json()}catch(a){throw new Error(`Expected a JSON response when doing a POST request on "${e}". ${String(a)}`)}if(!mn(r)||typeof r.token!="string")throw new Error(`Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${e}", but got ${JSON.stringify(r)}`);const{token:i}=r;return{token:i}}var sr="https://api.liveblocks.io",Q=Symbol(),rr=P();rr.observable;function ct(t,...e){if(typeof t!="object"||t===null||Array.isArray(t))return JSON.stringify(t,...e);const n=Object.keys(t).sort().reduce((s,r)=>(s[r]=t[r],s),{});return JSON.stringify(n,...e)}var ir=50,or=100,tt=()=>{},ar=class{constructor(t){this.resolve=tt,this.reject=tt,this.promise=new Promise(tt),this.args=t}},vt=class{constructor(t,e){this.queue=[],this.error=!1,this.callback=t,this.size=(e==null?void 0:e.size)??ir,this.delay=(e==null?void 0:e.delay)??or}clearDelayTimeout(){this.delayTimeoutId!==void 0&&(clearTimeout(this.delayTimeoutId),this.delayTimeoutId=void 0)}schedule(){this.queue.length===this.size?this.flush():this.queue.length===1&&(this.clearDelayTimeout(),this.delayTimeoutId=setTimeout(()=>void this.flush(),this.delay))}async flush(){if(this.queue.length===0)return;const t=this.queue.splice(0),e=t.map(n=>n.args);try{const n=await this.callback(e);this.error=!1,t.forEach((s,r)=>{const i=n==null?void 0:n[r];Array.isArray(n)?t.length!==n.length?s.reject(new Error(`Callback must return an array of the same length as the number of provided items. Expected ${t.length}, but got ${n.length}.`)):i instanceof Error?s.reject(i):s.resolve(i):s.reject(new Error("Callback must return an array."))})}catch(n){this.error=!0,t.forEach(s=>{s.reject(n)})}}get(...t){const e=this.queue.find(s=>ct(s.args)===ct(t));if(e)return e.promise;const n=new ar(t);return n.promise=new Promise((s,r)=>{n.resolve=s,n.reject=r}),this.queue.push(n),this.schedule(),n.promise}clear(){this.queue=[],this.error=!1,this.clearDelayTimeout()}};function Wt(t,e){const n=new vt(t,e),s=new Map,r=P();function i(d){return ct(d)}function a(d,m){m?s.set(d,m):s.delete(d),r.notify(m)}async function c(...d){const m=i(d);if(!s.has(m))try{a(m,{isLoading:!0});const _=await n.get(...d);a(m,{isLoading:!1,data:_})}catch(_){a(m,{isLoading:!1,error:_})}}function o(...d){const m=i(d);return s.get(m)}return{...r,get:c,getState:o}}function En(t){let e=t;const n=new Set;function s(){return e}function r(a){const c=a(e);if(e!==c){e=c;for(const o of n)o(e)}}function i(a){return n.add(a),a(e),()=>{n.delete(a)}}return{get:s,set:r,subscribe:i}}function ut(t){const e=t.editedAt?new Date(t.editedAt):void 0,n=new Date(t.createdAt),s=t.reactions.map(r=>({...r,createdAt:new Date(r.createdAt)}));if(t.body)return{...t,reactions:s,createdAt:n,editedAt:e};{const r=new Date(t.deletedAt);return{...t,reactions:s,createdAt:n,editedAt:e,deletedAt:r}}}function He(t){const e=t.updatedAt?new Date(t.updatedAt):void 0,n=new Date(t.createdAt),s=t.comments.map(r=>ut(r));return{...t,createdAt:n,updatedAt:e,comments:s}}function cr(t){return{...t,createdAt:new Date(t.createdAt)}}function dt(t){const e=new Date(t.notifiedAt),n=t.readAt?new Date(t.readAt):null;if("activities"in t){const s=t.activities.map(r=>({...r,createdAt:new Date(r.createdAt)}));return{...t,notifiedAt:e,readAt:n,activities:s}}return{...t,notifiedAt:e,readAt:n}}function Sn(t){const e=new Date(t.deletedAt);return{...t,deletedAt:e}}function Tn(t){const e=new Date(t.deletedAt);return{...t,deletedAt:e}}function ur(t){const e=new URLSearchParams;for(const[n,s]of Object.entries(t))s!=null&&e.set(n,s.toString());return e}function In(t,e,n){const s=new URL(e,t);return n!==void 0&&(s.search=(n instanceof URLSearchParams?n:ur(n)).toString()),s.toString()}var dr=50;function lr({baseUrl:t,authManager:e,currentUserIdStore:n,fetcher:s}){async function r(_,g,E){const w=await e.getAuthValue({requestedScope:"comments:read"});if(w.type==="secret"&&w.token.parsed.k==="acc"){const f=w.token.parsed.uid;n.set(()=>f)}const y=In(t,`/v2/c${_}`,E),b=await s(y.toString(),{...g,headers:{...g==null?void 0:g.headers,Authorization:`Bearer ${mt(w)}`}});if(!b.ok&&b.status>=400&&b.status<600){let f;try{const h=await b.json();f=new Oe(h.message,b.status,h)}catch{f=new Oe(b.statusText,b.status)}throw f}let S;try{S=await b.json()}catch{S={}}return S}async function i(_){var E;const g=await r("/inbox-notifications",void 0,{limit:_==null?void 0:_.limit,since:(E=_==null?void 0:_.since)==null?void 0:E.toISOString()});return{threads:g.threads.map(w=>He(w)),inboxNotifications:g.inboxNotifications.map(w=>dt(w)),deletedThreads:g.deletedThreads.map(w=>Sn(w)),deletedInboxNotifications:g.deletedInboxNotifications.map(w=>Tn(w)),meta:{requestedAt:new Date(g.meta.requestedAt)}}}async function a(){const{count:_}=await r("/inbox-notifications/count");return _}async function c(){await r("/inbox-notifications/read",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inboxNotificationIds:"all"})})}async function o(_){await r("/inbox-notifications/read",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inboxNotificationIds:_})})}const d=new vt(async _=>{const g=_.flat();return await o(g),g},{delay:dr});async function m(_){await d.get(_)}return{getInboxNotifications:i,getUnreadInboxNotificationsCount:a,markAllInboxNotificationsAsRead:c,markInboxNotificationAsRead:m}}var W=32,ne=126,fr=ne-W+1,gt=bt(0),We=bt(1),hr=gt+bt(-1);function bt(t){const e=W+(t<0?fr+t:t);if(e<W||e>ne)throw new Error(`Invalid n value: ${t}`);return String.fromCharCode(e)}function Z(t,e){return t!==void 0&&e!==void 0?_r(t,e):t!==void 0?mr(t):e!==void 0?pr(e):We}function pr(t){const e=t.length-1;for(let n=0;n<=e;n++){const s=t.charCodeAt(n);if(!(s<=W))return n===e?s===W+1?t.substring(0,n)+hr:t.substring(0,n)+String.fromCharCode(s-1):t.substring(0,n+1)}return We}function mr(t){for(let e=0;e<=t.length-1;e++){const n=t.charCodeAt(e);if(!(n>=ne))return t.substring(0,e)+String.fromCharCode(n+1)}return t+We}function _r(t,e){if(t<e)return lt(t,e);if(t>e)return lt(e,t);throw new Error("Cannot compute value between two equal positions")}function lt(t,e){let n=0;const s=t.length,r=e.length;for(;;){const i=n<s?t.charCodeAt(n):W,a=n<r?e.charCodeAt(n):ne;if(i===a){n++;continue}if(a-i===1){const c=n+1;let o=t.substring(0,c);o.length<c&&(o+=gt.repeat(c-o.length));const d=t.substring(c);return o+lt(d,"")}else return yr(t,n)+String.fromCharCode(a+i>>1)}}function yr(t,e){return e<t.length?t.substring(0,e):t+gt.repeat(e-t.length)}var vr=W+1;function gr(t){if(t==="")return!1;const e=t.length-1,n=t.charCodeAt(e);if(n<vr||n>ne)return!1;for(let s=0;s<e;s++){const r=t.charCodeAt(s);if(r<W||r>ne)return!1}return!0}function br(t){const e=[];for(let n=0;n<t.length;n++){const s=t.charCodeAt(n);e.push(s<W?W:s>ne?ne:s)}for(;e.length>0&&e[e.length-1]===W;)e.length--;return e.length>0?String.fromCharCode(...e):We}function Ie(t){return gr(t)?t:br(t)}function wr(t){return t.type===5&&t.id==="ACK"}function Bt(t,e,n=Ie(e)){return Object.freeze({type:"HasParent",node:t,key:e,pos:n})}var Jt=Object.freeze({type:"NoParent"});function Er(t,e=Ie(t)){return Object.freeze({type:"Orphaned",oldKey:t,oldPos:e})}var Be=class{constructor(){this._parent=Jt}_getParentKeyOrThrow(){switch(this.parent.type){case"HasParent":return this.parent.key;case"NoParent":throw new Error("Parent key is missing");case"Orphaned":return this.parent.oldKey;default:return X(this.parent,"Unknown state")}}get _parentPos(){switch(this.parent.type){case"HasParent":return this.parent.pos;case"NoParent":throw new Error("Parent key is missing");case"Orphaned":return this.parent.oldPos;default:return X(this.parent,"Unknown state")}}get _pool(){return this.__pool}get roomId(){return this.__pool?this.__pool.roomId:null}get _id(){return this.__id}get parent(){return this._parent}get _parentKey(){switch(this.parent.type){case"HasParent":return this.parent.key;case"NoParent":return null;case"Orphaned":return this.parent.oldKey;default:return X(this.parent,"Unknown state")}}_apply(t,e){switch(t.type){case 5:return this.parent.type==="HasParent"?this.parent.node._detachChild(this):{modified:!1}}return{modified:!1}}_setParentLink(t,e){switch(this.parent.type){case"HasParent":if(this.parent.node!==t)throw new Error("Cannot set parent: node already has a parent");this._parent=Bt(t,e);return;case"Orphaned":case"NoParent":{this._parent=Bt(t,e);return}default:return X(this.parent,"Unknown state")}}_attach(t,e){if(this.__id||this.__pool)throw new Error("Cannot attach node: already attached");e.addNode(t,this),this.__id=t,this.__pool=e}_detach(){switch(this.__pool&&this.__id&&this.__pool.deleteNode(this.__id),this.parent.type){case"HasParent":{this._parent=Er(this.parent.key,this.parent.pos);break}case"NoParent":{this._parent=Jt;break}case"Orphaned":break;default:X(this.parent,"Unknown state")}this.__pool=void 0}invalidate(){(this._cachedImmutable!==void 0||this._cachedTreeNode!==void 0)&&(this._cachedImmutable=void 0,this._cachedTreeNode=void 0,this.parent.type==="HasParent"&&this.parent.node.invalidate())}toTreeNode(t){return(this._cachedTreeNode===void 0||this._cachedTreeNodeKey!==t)&&(this._cachedTreeNodeKey=t,this._cachedTreeNode=this._toTreeNode(t)),this._cachedTreeNode}toImmutable(){return this._cachedImmutable===void 0&&(this._cachedImmutable=this._toImmutable()),this._cachedImmutable}};function Sr(t){return t.type===0&&!Tr(t)}function Tr(t){return t.parentId!==void 0&&t.parentKey!==void 0}function Je(t=7){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-",n=e.length;return Array.from({length:t},()=>e.charAt(Math.floor(Math.random()*n))).join("")}var ae=class On extends Be{constructor(e){super(),this._data=e}get data(){return this._data}static _deserialize([e,n],s,r){const i=new On(n.data);return i._attach(e,r),i}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize register if parentId or parentKey is undefined");return[{type:8,opId:s==null?void 0:s.generateOpId(),id:this._id,parentId:e,parentKey:n,data:this.data}]}_serialize(){if(this.parent.type!=="HasParent")throw new Error("Cannot serialize LiveRegister if parent is missing");return{type:3,parentId:k(this.parent.node._id,"Parent node expected to have ID"),parentKey:this.parent.key,data:this.data}}_attachChild(e){throw new Error("Method not implemented.")}_detachChild(e){throw new Error("Method not implemented.")}_apply(e,n){return super._apply(e,n)}_toTreeNode(e){return{type:"Json",id:this._id??Je(),key:e,payload:this._data}}_toImmutable(){return this._data}clone(){return Te(this.data)}};function Ir(t,e){const n=t._parentPos,s=e._parentPos;return n===s?0:n<s?-1:1}var ce=class ft extends Be{constructor(e){super(),this._items=[],this._implicitlyDeletedItems=new WeakSet,this._unacknowledgedSets=new Map;let n;for(const s of e){const r=Z(n),i=me(s);i._setParentLink(this,r),this._items.push(i),n=r}}static _deserialize([e],n,s){const r=new ft([]);r._attach(e,s);const i=n.get(e);if(i===void 0)return r;for(const[a,c]of i){const o=Cn([a,c],n,s);o._setParentLink(r,c.parentKey),r._insertAndSort(o)}return r}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize item is not attached");const r=[],i={id:this._id,opId:s==null?void 0:s.generateOpId(),type:2,parentId:e,parentKey:n};r.push(i);for(const a of this._items){const c=a._getParentKeyOrThrow(),o=je(a._toOps(this._id,c,s),void 0),d=o[0].opId;d!==void 0&&this._unacknowledgedSets.set(c,d),r.push(...o)}return r}_insertAndSort(e){this._items.push(e),this._sortItems()}_sortItems(){this._items.sort(Ir),this.invalidate()}_indexOfPosition(e){return this._items.findIndex(n=>n._getParentKeyOrThrow()===e)}_attach(e,n){super._attach(e,n);for(const s of this._items)s._attach(n.generateId(),n)}_detach(){super._detach();for(const e of this._items)e._detach()}_applySetRemote(e){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const{id:n,parentKey:s}=e,r=Ee(e);r._attach(n,this._pool),r._setParentLink(this,s);const i=e.deletedId,a=this._indexOfPosition(s);if(a!==-1){const c=this._items[a];if(c._id===i)return c._detach(),this._items[a]=r,{modified:N(this,[fe(a,r)]),reverse:[]};{this._implicitlyDeletedItems.add(c),this._items[a]=r;const o=[fe(a,r)],d=this._detachItemAssociatedToSetOperation(e.deletedId);return d&&o.push(d),{modified:N(this,o),reverse:[]}}}else{const c=[],o=this._detachItemAssociatedToSetOperation(e.deletedId);return o&&c.push(o),this._insertAndSort(r),c.push(q(this._indexOfPosition(s),r)),{reverse:[],modified:N(this,c)}}}_applySetAck(e){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const n=[],s=this._detachItemAssociatedToSetOperation(e.deletedId);s&&n.push(s);const r=this._unacknowledgedSets.get(e.parentKey);if(r!==void 0){if(r!==e.opId)return n.length===0?{modified:!1}:{modified:N(this,n),reverse:[]};this._unacknowledgedSets.delete(e.parentKey)}const i=this._indexOfPosition(e.parentKey),a=this._items.find(c=>c._id===e.id);if(a!==void 0){if(a._parentKey===e.parentKey)return{modified:n.length>0?N(this,n):!1,reverse:[]};i!==-1&&(this._implicitlyDeletedItems.add(this._items[i]),this._items.splice(i,1),n.push($e(i)));const c=this._items.indexOf(a);a._setParentLink(this,e.parentKey),this._sortItems();const o=this._items.indexOf(a);return o!==c&&n.push(re(c,o,a)),{modified:n.length>0?N(this,n):!1,reverse:[]}}else{const c=this._pool.getNode(e.id);if(c&&this._implicitlyDeletedItems.has(c)){c._setParentLink(this,e.parentKey),this._implicitlyDeletedItems.delete(c),this._insertAndSort(c);const o=this._items.indexOf(c);return{modified:N(this,[i===-1?q(o,c):fe(o,c),...n]),reverse:[]}}else{i!==-1&&this._items.splice(i,1);const{newItem:o,newIndex:d}=this._createAttachItemAndSort(e,e.parentKey);return{modified:N(this,[i===-1?q(d,o):fe(d,o),...n]),reverse:[]}}}}_detachItemAssociatedToSetOperation(e){if(e===void 0||this._pool===void 0)return null;const n=this._pool.getNode(e);if(n===void 0)return null;const s=this._detachChild(n);return s.modified===!1?null:s.modified.updates[0]}_applyRemoteInsert(e){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const n=Ie(e.parentKey),s=this._indexOfPosition(n);s!==-1&&this._shiftItemPosition(s,n);const{newItem:r,newIndex:i}=this._createAttachItemAndSort(e,n);return{modified:N(this,[q(i,r)]),reverse:[]}}_applyInsertAck(e){const n=this._items.find(i=>i._id===e.id),s=Ie(e.parentKey),r=this._indexOfPosition(s);if(n){if(n._parentKey===s)return{modified:!1};{const i=this._items.indexOf(n);r!==-1&&this._shiftItemPosition(r,s),n._setParentLink(this,s),this._sortItems();const a=this._indexOfPosition(s);return a===i?{modified:!1}:{modified:N(this,[re(i,a,n)]),reverse:[]}}}else{const i=k(this._pool).getNode(e.id);if(i&&this._implicitlyDeletedItems.has(i)){i._setParentLink(this,s),this._implicitlyDeletedItems.delete(i),this._insertAndSort(i);const a=this._indexOfPosition(s);return{modified:N(this,[q(a,i)]),reverse:[]}}else{r!==-1&&this._shiftItemPosition(r,s);const{newItem:a,newIndex:c}=this._createAttachItemAndSort(e,s);return{modified:N(this,[q(c,a)]),reverse:[]}}}}_applyInsertUndoRedo(e){var o,d,m;const{id:n,parentKey:s}=e,r=Ee(e);if(((o=this._pool)==null?void 0:o.getNode(n))!==void 0)return{modified:!1};r._attach(n,k(this._pool)),r._setParentLink(this,s);const i=this._indexOfPosition(s);let a=s;if(i!==-1){const _=(d=this._items[i])==null?void 0:d._parentPos,g=(m=this._items[i+1])==null?void 0:m._parentPos;a=Z(_,g),r._setParentLink(this,a)}this._insertAndSort(r);const c=this._indexOfPosition(a);return{modified:N(this,[q(c,r)]),reverse:[{type:5,id:n}]}}_applySetUndoRedo(e){var c;const{id:n,parentKey:s}=e,r=Ee(e);if(((c=this._pool)==null?void 0:c.getNode(n))!==void 0)return{modified:!1};this._unacknowledgedSets.set(s,k(e.opId));const i=this._indexOfPosition(s);r._attach(n,k(this._pool)),r._setParentLink(this,s);const a=s;if(i!==-1){const o=this._items[i];o._detach(),this._items[i]=r;const d=je(o._toOps(k(this._id),s,this._pool),e.id),m=[fe(i,r)],_=this._detachItemAssociatedToSetOperation(e.deletedId);return _&&m.push(_),{modified:N(this,m),reverse:d}}else{this._insertAndSort(r),this._detachItemAssociatedToSetOperation(e.deletedId);const o=this._indexOfPosition(a);return{reverse:[{type:5,id:n}],modified:N(this,[q(o,r)])}}}_attachChild(e,n){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");let s;return e.intent==="set"?n===1?s=this._applySetRemote(e):n===2?s=this._applySetAck(e):s=this._applySetUndoRedo(e):n===1?s=this._applyRemoteInsert(e):n===2?s=this._applyInsertAck(e):s=this._applyInsertUndoRedo(e),s.modified!==!1&&this.invalidate(),s}_detachChild(e){if(e){const n=k(e._parentKey),s=e._toOps(k(this._id),n,this._pool),r=this._items.indexOf(e);return r===-1?{modified:!1}:(this._items.splice(r,1),this.invalidate(),e._detach(),{modified:N(this,[$e(r)]),reverse:s})}return{modified:!1}}_applySetChildKeyRemote(e,n){var i;if(this._implicitlyDeletedItems.has(n)){this._implicitlyDeletedItems.delete(n),n._setParentLink(this,e),this._insertAndSort(n);const a=this._items.indexOf(n);return{modified:N(this,[q(a,n)]),reverse:[]}}const s=n._parentKey;if(e===s)return{modified:!1};const r=this._indexOfPosition(e);if(r===-1){const a=this._items.indexOf(n);n._setParentLink(this,e),this._sortItems();const c=this._items.indexOf(n);return c===a?{modified:!1}:{modified:N(this,[re(a,c,n)]),reverse:[]}}else{this._items[r]._setParentLink(this,Z(e,(i=this._items[r+1])==null?void 0:i._parentPos));const a=this._items.indexOf(n);n._setParentLink(this,e),this._sortItems();const c=this._items.indexOf(n);return c===a?{modified:!1}:{modified:N(this,[re(a,c,n)]),reverse:[]}}}_applySetChildKeyAck(e,n){var r,i;const s=k(n._parentKey);if(this._implicitlyDeletedItems.has(n)){const a=this._indexOfPosition(e);return this._implicitlyDeletedItems.delete(n),a!==-1&&this._items[a]._setParentLink(this,Z(e,(r=this._items[a+1])==null?void 0:r._parentPos)),n._setParentLink(this,e),this._insertAndSort(n),{modified:!1}}else{if(e===s)return{modified:!1};const a=this._items.indexOf(n),c=this._indexOfPosition(e);c!==-1&&this._items[c]._setParentLink(this,Z(e,(i=this._items[c+1])==null?void 0:i._parentPos)),n._setParentLink(this,e),this._sortItems();const o=this._items.indexOf(n);return a===o?{modified:!1}:{modified:N(this,[re(a,o,n)]),reverse:[]}}}_applySetChildKeyUndoRedo(e,n){var c;const s=k(n._parentKey),r=this._items.indexOf(n),i=this._indexOfPosition(e);i!==-1&&this._items[i]._setParentLink(this,Z(e,(c=this._items[i+1])==null?void 0:c._parentPos)),n._setParentLink(this,e),this._sortItems();const a=this._items.indexOf(n);return r===a?{modified:!1}:{modified:N(this,[re(r,a,n)]),reverse:[{type:1,id:k(n._id),parentKey:s}]}}_setChildKey(e,n,s){return s===1?this._applySetChildKeyRemote(e,n):s===2?this._applySetChildKeyAck(e,n):this._applySetChildKeyUndoRedo(e,n)}_apply(e,n){return super._apply(e,n)}_serialize(){if(this.parent.type!=="HasParent")throw new Error("Cannot serialize LiveList if parent is missing");return{type:1,parentId:k(this.parent.node._id,"Parent node expected to have ID"),parentKey:this.parent.key}}get length(){return this._items.length}push(e){var n;return(n=this._pool)==null||n.assertStorageIsWritable(),this.insert(e,this.length)}insert(e,n){var c;if((c=this._pool)==null||c.assertStorageIsWritable(),n<0||n>this._items.length)throw new Error(`Cannot insert list item at index "${n}". index should be between 0 and ${this._items.length}`);const s=this._items[n-1]?this._items[n-1]._parentPos:void 0,r=this._items[n]?this._items[n]._parentPos:void 0,i=Z(s,r),a=me(e);if(a._setParentLink(this,i),this._insertAndSort(a),this._pool&&this._id){const o=this._pool.generateId();a._attach(o,this._pool),this._pool.dispatch(a._toOps(this._id,i,this._pool),[{type:5,id:o}],new Map([[this._id,N(this,[q(n,a)])]]))}}move(e,n){var o;if((o=this._pool)==null||o.assertStorageIsWritable(),n<0)throw new Error("targetIndex cannot be less than 0");if(n>=this._items.length)throw new Error("targetIndex cannot be greater or equal than the list length");if(e<0)throw new Error("index cannot be less than 0");if(e>=this._items.length)throw new Error("index cannot be greater or equal than the list length");let s=null,r=null;e<n?(r=n===this._items.length-1?void 0:this._items[n+1]._parentPos,s=this._items[n]._parentPos):(r=this._items[n]._parentPos,s=n===0?void 0:this._items[n-1]._parentPos);const i=Z(s,r),a=this._items[e],c=a._getParentKeyOrThrow();if(a._setParentLink(this,i),this._sortItems(),this._pool&&this._id){const d=new Map([[this._id,N(this,[re(e,n,a)])]]);this._pool.dispatch([{type:1,id:k(a._id),opId:this._pool.generateOpId(),parentKey:i}],[{type:1,id:k(a._id),parentKey:c}],d)}}delete(e){var s;if((s=this._pool)==null||s.assertStorageIsWritable(),e<0||e>=this._items.length)throw new Error(`Cannot delete list item at index "${e}". index should be between 0 and ${this._items.length-1}`);const n=this._items[e];if(n._detach(),this._items.splice(e,1),this.invalidate(),this._pool){const r=n._id;if(r){const i=new Map;i.set(k(this._id),N(this,[$e(e)])),this._pool.dispatch([{id:r,opId:this._pool.generateOpId(),type:5}],n._toOps(k(this._id),n._getParentKeyOrThrow()),i)}}}clear(){var e;if((e=this._pool)==null||e.assertStorageIsWritable(),this._pool){const n=[],s=[],r=[];for(const a of this._items){a._detach();const c=a._id;c&&(n.push({type:5,id:c,opId:this._pool.generateOpId()}),s.push(...a._toOps(k(this._id),a._getParentKeyOrThrow())),r.push($e(0)))}this._items=[],this.invalidate();const i=new Map;i.set(k(this._id),N(this,r)),this._pool.dispatch(n,s,i)}else{for(const n of this._items)n._detach();this._items=[],this.invalidate()}}set(e,n){var c;if((c=this._pool)==null||c.assertStorageIsWritable(),e<0||e>=this._items.length)throw new Error(`Cannot set list item at index "${e}". index should be between 0 and ${this._items.length-1}`);const s=this._items[e],r=s._getParentKeyOrThrow(),i=s._id;s._detach();const a=me(n);if(a._setParentLink(this,r),this._items[e]=a,this.invalidate(),this._pool&&this._id){const o=this._pool.generateId();a._attach(o,this._pool);const d=new Map;d.set(this._id,N(this,[fe(e,a)]));const m=je(a._toOps(this._id,r,this._pool),i);this._unacknowledgedSets.set(r,k(m[0].opId));const _=je(s._toOps(this._id,r,void 0),o);this._pool.dispatch(m,_,d)}}toArray(){return this._items.map(e=>oe(e))}every(e){return this.toArray().every(e)}filter(e){return this.toArray().filter(e)}find(e){return this.toArray().find(e)}findIndex(e){return this.toArray().findIndex(e)}forEach(e){return this.toArray().forEach(e)}get(e){if(!(e<0||e>=this._items.length))return oe(this._items[e])}indexOf(e,n){return this.toArray().indexOf(e,n)}lastIndexOf(e,n){return this.toArray().lastIndexOf(e,n)}map(e){return this._items.map((n,s)=>e(oe(n),s))}some(e){return this.toArray().some(e)}[Symbol.iterator](){return new Or(this._items)}_createAttachItemAndSort(e,n){const s=Ee(e);s._attach(e.id,k(this._pool)),s._setParentLink(this,n),this._insertAndSort(s);const r=this._indexOfPosition(n);return{newItem:s,newIndex:r}}_shiftItemPosition(e,n){var r;const s=Z(n,this._items.length>e+1?(r=this._items[e+1])==null?void 0:r._parentPos:void 0);this._items[e]._setParentLink(this,s)}_toTreeNode(e){return{type:"LiveList",id:this._id??Je(),key:e,payload:this._items.map((n,s)=>n.toTreeNode(s.toString()))}}toImmutable(){return super.toImmutable()}_toImmutable(){return this._items.map(n=>n.toImmutable())}clone(){return new ft(this._items.map(e=>e.clone()))}},Or=class{constructor(t){this._innerIterator=t[Symbol.iterator]()}[Symbol.iterator](){return this}next(){const t=this._innerIterator.next();return t.done?{done:!0,value:void 0}:{value:oe(t.value)}}};function N(t,e){return{node:t,type:"LiveList",updates:e}}function fe(t,e){return{index:t,type:"set",item:e instanceof ae?e.data:e}}function $e(t){return{index:t,type:"delete"}}function q(t,e){return{index:t,type:"insert",item:e instanceof ae?e.data:e}}function re(t,e,n){return{index:e,type:"move",previousIndex:t,item:n instanceof ae?n.data:n}}function je(t,e){return t.map((n,s)=>s===0?{...n,intent:"set",deletedId:e}:n)}var ee=t=>t,ue=class ht extends Be{constructor(e){if(super(),this.unacknowledgedSet=new Map,e){const n=[];for(const[s,r]of e){const i=me(r);i._setParentLink(this,s),n.push([s,i])}this._map=new Map(n)}else this._map=new Map}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize item is not attached");const r=[],i={id:this._id,opId:s==null?void 0:s.generateOpId(),type:7,parentId:e,parentKey:n};r.push(i);for(const[a,c]of this._map)r.push(...c._toOps(this._id,a,s));return r}static _deserialize([e,n],s,r){const i=new ht;i._attach(e,r);const a=s.get(e);if(a===void 0)return i;for(const[c,o]of a){const d=Cn([c,o],s,r);d._setParentLink(i,o.parentKey),i._map.set(o.parentKey,d),i.invalidate()}return i}_attach(e,n){super._attach(e,n);for(const[s,r]of this._map)x(r)&&r._attach(n.generateId(),n)}_attachChild(e,n){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const{id:s,parentKey:r,opId:i}=e,a=r,c=Ee(e);if(this._pool.getNode(s)!==void 0)return{modified:!1};if(n===2){const m=this.unacknowledgedSet.get(a);if(m===i)return this.unacknowledgedSet.delete(a),{modified:!1};if(m!==void 0)return{modified:!1}}else n===1&&this.unacknowledgedSet.delete(a);const o=this._map.get(a);let d;if(o){const m=k(this._id);d=o._toOps(m,a),o._detach()}else d=[{type:5,id:s}];return c._setParentLink(this,a),c._attach(s,this._pool),this._map.set(a,c),this.invalidate(),{modified:{node:this,type:"LiveMap",updates:{[a]:{type:"update"}}},reverse:d}}_detach(){super._detach();for(const e of this._map.values())e._detach()}_detachChild(e){const n=k(this._id),s=k(e._parentKey),r=e._toOps(n,s,this._pool);for(const[a,c]of this._map)c===e&&(this._map.delete(a),this.invalidate());return e._detach(),{modified:{node:this,type:"LiveMap",updates:{[s]:{type:"delete"}}},reverse:r}}_serialize(){if(this.parent.type!=="HasParent")throw new Error("Cannot serialize LiveMap if parent is missing");return{type:2,parentId:k(this.parent.node._id,"Parent node expected to have ID"),parentKey:this.parent.key}}get(e){const n=this._map.get(e);if(n!==void 0)return oe(n)}set(e,n){var i;(i=this._pool)==null||i.assertStorageIsWritable();const s=this._map.get(e);s&&s._detach();const r=me(n);if(r._setParentLink(this,e),this._map.set(e,r),this.invalidate(),this._pool&&this._id){const a=this._pool.generateId();r._attach(a,this._pool);const c=new Map;c.set(this._id,{node:this,type:"LiveMap",updates:{[e]:{type:"update"}}});const o=r._toOps(this._id,e,this._pool);this.unacknowledgedSet.set(e,k(o[0].opId)),this._pool.dispatch(r._toOps(this._id,e,this._pool),s?s._toOps(this._id,e):[{type:5,id:a}],c)}}get size(){return this._map.size}has(e){return this._map.has(e)}delete(e){var s;(s=this._pool)==null||s.assertStorageIsWritable();const n=this._map.get(e);if(n===void 0)return!1;if(n._detach(),this._map.delete(e),this.invalidate(),this._pool&&n._id){const r=k(this._id),i=new Map;i.set(r,{node:this,type:"LiveMap",updates:{[e]:{type:"delete"}}}),this._pool.dispatch([{type:5,id:n._id,opId:this._pool.generateOpId()}],n._toOps(r,e),i)}return!0}entries(){const e=this._map.entries();return{[Symbol.iterator](){return this},next(){const n=e.next();if(n.done)return{done:!0,value:void 0};const r=n.value[0],i=oe(n.value[1]);return{value:[r,i]}}}}[Symbol.iterator](){return this.entries()}keys(){return this._map.keys()}values(){const e=this._map.values();return{[Symbol.iterator](){return this},next(){const n=e.next();return n.done?{done:!0,value:void 0}:{value:oe(n.value)}}}}forEach(e){for(const n of this)e(n[1],n[0],this)}_toTreeNode(e){return{type:"LiveMap",id:this._id??Je(),key:e,payload:Array.from(this._map.entries()).map(([n,s])=>s.toTreeNode(n))}}toImmutable(){return super.toImmutable()}_toImmutable(){const e=new Map;for(const[n,s]of this._map)e.set(n,s.toImmutable());return ee(e)}clone(){return new ht(Array.from(this._map).map(([e,n])=>[e,n.clone()]))}},de=class we extends Be{static _buildRootAndParentToChildren(e){const n=new Map;let s=null;for(const[r,i]of e)if(Sr(i))s=[r,i];else{const a=[r,i],c=n.get(i.parentId);c!==void 0?c.push(a):n.set(i.parentId,[a])}if(s===null)throw new Error("Root can't be null");return[s,n]}static _fromItems(e,n){const[s,r]=we._buildRootAndParentToChildren(e);return we._deserialize(s,r,n)}constructor(e={}){super(),this._propToLastUpdate=new Map;const n=ze(e);for(const s of Object.keys(n)){const r=n[s];x(r)&&r._setParentLink(this,s)}this._map=new Map(Object.entries(n))}_toOps(e,n,s){if(this._id===void 0)throw new Error("Cannot serialize item is not attached");const r=s==null?void 0:s.generateOpId(),i=[],a={type:4,id:this._id,opId:r,parentId:e,parentKey:n,data:{}};i.push(a);for(const[c,o]of this._map)x(o)?i.push(...o._toOps(this._id,c,s)):a.data[c]=o;return i}static _deserialize([e,n],s,r){const i=new we(n.data);return i._attach(e,r),this._deserializeChildren(i,s,r)}static _deserializeChildren(e,n,s){const r=n.get(k(e._id));if(r===void 0)return e;for(const[i,a]of r){const c=kr([i,a],n,s);pe(c)&&c._setParentLink(e,a.parentKey),e._map.set(a.parentKey,c),e.invalidate()}return e}_attach(e,n){super._attach(e,n);for(const[s,r]of this._map)x(r)&&r._attach(n.generateId(),n)}_attachChild(e,n){if(this._pool===void 0)throw new Error("Can't attach child if managed pool is not present");const{id:s,opId:r,parentKey:i}=e,a=kn(e);if(this._pool.getNode(s)!==void 0)return this._propToLastUpdate.get(i)===r&&this._propToLastUpdate.delete(i),{modified:!1};if(n===0)this._propToLastUpdate.set(i,k(r));else if(this._propToLastUpdate.get(i)!==void 0)return this._propToLastUpdate.get(i)===r?(this._propToLastUpdate.delete(i),{modified:!1}):{modified:!1};const c=k(this._id),o=this._map.get(i);let d;return x(o)?(d=o._toOps(c,i),o._detach()):o===void 0?d=[{type:6,id:c,key:i}]:d=[{type:3,id:c,data:{[i]:o}}],this._map.set(i,a),this.invalidate(),pe(a)&&(a._setParentLink(this,i),a._attach(s,this._pool)),{reverse:d,modified:{node:this,type:"LiveObject",updates:{[i]:{type:"update"}}}}}_detachChild(e){if(e){const n=k(this._id),s=k(e._parentKey),r=e._toOps(n,s,this._pool);for(const[a,c]of this._map)c===e&&(this._map.delete(a),this.invalidate());return e._detach(),{modified:{node:this,type:"LiveObject",updates:{[s]:{type:"delete"}}},reverse:r}}return{modified:!1}}_detach(){super._detach();for(const e of this._map.values())x(e)&&e._detach()}_apply(e,n){return e.type===3?this._applyUpdate(e,n):e.type===6?this._applyDeleteObjectKey(e,n):super._apply(e,n)}_serialize(){const e={};for(const[n,s]of this._map)x(s)||(e[n]=s);return this.parent.type==="HasParent"&&this.parent.node._id?{type:0,parentId:this.parent.node._id,parentKey:this.parent.key,data:e}:{type:0,data:e}}_applyUpdate(e,n){let s=!1;const r=k(this._id),i=[],a={type:3,id:r,data:{}};for(const o in e.data){const d=this._map.get(o);x(d)?(i.push(...d._toOps(r,o)),d._detach()):d!==void 0?a.data[o]=d:d===void 0&&i.push({type:6,id:r,key:o})}const c={};for(const o in e.data){const d=e.data[o];if(d===void 0)continue;if(n)this._propToLastUpdate.set(o,k(e.opId));else if(this._propToLastUpdate.get(o)===void 0)s=!0;else if(this._propToLastUpdate.get(o)===e.opId){this._propToLastUpdate.delete(o);continue}else continue;const m=this._map.get(o);x(m)&&m._detach(),s=!0,c[o]={type:"update"},this._map.set(o,d),this.invalidate()}return Object.keys(a.data).length!==0&&i.unshift(a),s?{modified:{node:this,type:"LiveObject",updates:c},reverse:i}:{modified:!1}}_applyDeleteObjectKey(e,n){const s=e.key;if(this._map.has(s)===!1)return{modified:!1};if(!n&&this._propToLastUpdate.get(s)!==void 0)return{modified:!1};const r=this._map.get(s),i=k(this._id);let a=[];return x(r)?(a=r._toOps(i,e.key),r._detach()):r!==void 0&&(a=[{type:3,id:i,data:{[s]:r}}]),this._map.delete(s),this.invalidate(),{modified:{node:this,type:"LiveObject",updates:{[e.key]:{type:"delete"}}},reverse:a}}toObject(){return Object.fromEntries(this._map)}set(e,n){var s;(s=this._pool)==null||s.assertStorageIsWritable(),this.update({[e]:n})}get(e){return this._map.get(e)}delete(e){var a;(a=this._pool)==null||a.assertStorageIsWritable();const n=e,s=this._map.get(n);if(s===void 0)return;if(this._pool===void 0||this._id===void 0){x(s)&&s._detach(),this._map.delete(n),this.invalidate();return}let r;x(s)?(s._detach(),r=s._toOps(this._id,n)):r=[{type:3,data:{[n]:s},id:this._id}],this._map.delete(n),this.invalidate();const i=new Map;i.set(this._id,{node:this,type:"LiveObject",updates:{[e]:{type:"delete"}}}),this._pool.dispatch([{type:6,key:n,id:this._id,opId:this._pool.generateOpId()}],r,i)}update(e){var d;if((d=this._pool)==null||d.assertStorageIsWritable(),this._pool===void 0||this._id===void 0){for(const m in e){const _=e[m];if(_===void 0)continue;const g=this._map.get(m);x(g)&&g._detach(),x(_)&&_._setParentLink(this,m),this._map.set(m,_),this.invalidate()}return}const n=[],s=[],r=this._pool.generateOpId(),i={},a={id:this._id,type:3,data:{}},c={};for(const m in e){const _=e[m];if(_===void 0)continue;const g=this._map.get(m);if(x(g)?(s.push(...g._toOps(this._id,m)),g._detach()):g===void 0?s.push({type:6,id:this._id,key:m}):a.data[m]=g,x(_)){_._setParentLink(this,m),_._attach(this._pool.generateId(),this._pool);const E=_._toOps(this._id,m,this._pool),w=E.find(y=>y.parentId===this._id);w&&this._propToLastUpdate.set(m,k(w.opId)),n.push(...E)}else i[m]=_,this._propToLastUpdate.set(m,r);this._map.set(m,_),this.invalidate(),c[m]={type:"update"}}Object.keys(a.data).length!==0&&s.unshift(a),Object.keys(i).length!==0&&n.unshift({opId:r,id:this._id,type:3,data:i});const o=new Map;o.set(this._id,{node:this,type:"LiveObject",updates:c}),this._pool.dispatch(n,s,o)}toImmutable(){return super.toImmutable()}toTreeNode(e){return super.toTreeNode(e)}_toTreeNode(e){const n=this._id??Je();return{type:"LiveObject",id:n,key:e,payload:Array.from(this._map.entries()).map(([s,r])=>x(r)?r.toTreeNode(s):{type:"Json",id:`${n}:${s}`,key:s,payload:r})}}_toImmutable(){const e={};for(const[n,s]of this._map)e[n]=pe(s)?s.toImmutable():s;return e}clone(){return new we(Object.fromEntries(Array.from(this._map).map(([e,n])=>[e,pe(n)?n.clone():Te(n)])))}};function Ee(t){return me(kn(t))}function kn(t){switch(t.type){case 8:return t.data;case 4:return new de(t.data);case 7:return new ue;case 2:return new ce([]);default:return X(t,"Unknown creation Op")}}function An(t,e){return t===e?!0:t.parent.type==="HasParent"?An(t.parent.node,e):!1}function Cn([t,e],n,s){switch(e.type){case 0:return de._deserialize([t,e],n,s);case 1:return ce._deserialize([t,e],n,s);case 2:return ue._deserialize([t,e],n,s);case 3:return ae._deserialize([t,e],n,s);default:throw new Error("Unexpected CRDT type")}}function kr([t,e],n,s){switch(e.type){case 0:return de._deserialize([t,e],n,s);case 1:return ce._deserialize([t,e],n,s);case 2:return ue._deserialize([t,e],n,s);case 3:return e.data;default:throw new Error("Unexpected CRDT type")}}function pe(t){return Pn(t)||Ar(t)||Cr(t)}function x(t){return pe(t)||Pr(t)}function Pn(t){return t instanceof ce}function Ar(t){return t instanceof ue}function Cr(t){return t instanceof de}function Pr(t){return t instanceof ae}function Nr(t){return t===void 0?void 0:pe(t)?t.clone():Te(t)}function oe(t){return t instanceof ae?t.data:t instanceof ce||t instanceof ue||t instanceof de?t:X(t,"Unknown AbstractCrdt")}function me(t){return t instanceof de||t instanceof ue||t instanceof ce?t:new ae(t)}function Rr(t,e){const n=[];return t.forEach((s,r)=>{e.get(r)||n.push({type:5,id:r})}),e.forEach((s,r)=>{const i=t.get(r);if(i)s.type===0&&(i.type!==0||JSON.stringify(s.data)!==JSON.stringify(i.data))&&n.push({type:3,id:r,data:s.data}),s.parentKey!==i.parentKey&&n.push({type:1,id:r,parentKey:k(s.parentKey,"Parent key must not be missing")});else switch(s.type){case 3:n.push({type:8,id:r,parentId:s.parentId,parentKey:s.parentKey,data:s.data});break;case 1:n.push({type:2,id:r,parentId:s.parentId,parentKey:s.parentKey});break;case 0:if(s.parentId===void 0||s.parentKey===void 0)throw new Error("Internal error. Cannot serialize storage root into an operation");n.push({type:4,id:r,parentId:s.parentId,parentKey:s.parentKey,data:s.data});break;case 2:n.push({type:7,id:r,parentId:s.parentId,parentKey:s.parentKey});break}}),n}function Dr(t,e){const n=t.updates;for(const[s,r]of _n(e.updates))n[s]=r;return{...e,updates:n}}function Lr(t,e){const n=t.updates;for(const[s,r]of _n(e.updates))n[s]=r;return{...e,updates:n}}function xr(t,e){const n=t.updates;return{...e,updates:n.concat(e.updates)}}function nt(t,e){return t===void 0?e:t.type==="LiveObject"&&e.type==="LiveObject"?Dr(t,e):t.type==="LiveMap"&&e.type==="LiveMap"?Lr(t,e):t.type==="LiveList"&&e.type==="LiveList"?xr(t,e):e}function Ur(t){return t===null||typeof t=="string"||typeof t=="number"||typeof t=="boolean"}function Nn(t){return Array.isArray(t)}function Mr(t){return!Ur(t)&&!Nn(t)}var $r=/^[a-zA-Z_][a-zA-Z0-9_]*$/;function jr(t){let e=[];const n=Object.entries(t),s=[],r=[],i=[];return n.forEach(([a,c])=>{if(!$r.test(a))throw new Error("Key must only contain letters, numbers, _");qt(c)?s.push([a,c]):Xt(c)?r.push([a,c]):typeof c=="object"&&!("startsWith"in c)&&i.push([a,c])}),e=[...Gt(s),...Yt(r)],i.forEach(([a,c])=>{const o=Object.entries(c),d=[],m=[];o.forEach(([_,g])=>{if(Rn(_))throw new Error("Key cannot be empty");qt(g)?d.push([Qt(a,_),g]):Xt(g)&&m.push([Qt(a,_),g])}),e=[...e,...Gt(d),...Yt(m)]}),e.map(({key:a,operator:c,value:o})=>Kr(a,c,Fr(o))).join(" AND ")}var Gt=t=>{const e=[];return t.forEach(([n,s])=>{e.push({key:n,operator:":",value:s})}),e},Yt=t=>{const e=[];return t.forEach(([n,s])=>{"startsWith"in s&&typeof s.startsWith=="string"&&e.push({key:n,operator:"^",value:s.startsWith})}),e},qt=t=>typeof t=="string"||typeof t=="number"||typeof t=="boolean",Xt=t=>typeof t=="object"&&t!==null&&"startsWith"in t,Kr=(t,e,n)=>`${t}${e}${n}`,Qt=(t,e)=>e?`${t}[${JSON.stringify(e)}]`:t,Fr=t=>{if(typeof t=="string"){if(Rn(t))throw new Error("Value cannot be empty");return JSON.stringify(t)}return t.toString()},Rn=t=>!t||t.toString().trim()==="",Hr=(t=>(t[t.UPDATE_PRESENCE=100]="UPDATE_PRESENCE",t[t.BROADCAST_EVENT=103]="BROADCAST_EVENT",t[t.FETCH_STORAGE=200]="FETCH_STORAGE",t[t.UPDATE_STORAGE=201]="UPDATE_STORAGE",t[t.FETCH_YDOC=300]="FETCH_YDOC",t[t.UPDATE_YDOC=301]="UPDATE_YDOC",t))(Hr||{});function Dn(t,e){let n=!1;const s={...t};return Object.keys(e).forEach(r=>{const i=r,a=e[i];s[i]!==a&&(a===void 0?delete s[i]:s[i]=a,n=!0)}),n?s:t}var Ge=class{constructor(){this._ev=P()}get didInvalidate(){return this._ev.observable}invalidate(){this._cache!==void 0&&(this._cache=void 0,this._ev.notify())}get current(){return this._cache??(this._cache=this._toImmutable())}};function Vr(t,e){const{connectionId:n,id:s,info:r}=t,i=at(t.scopes);return ee(ze({connectionId:n,id:s,info:r,canWrite:i,canComment:wn(t.scopes),isReadOnly:!i,presence:e}))}var zr=class extends Ge{constructor(){super(),this._connections=new Map,this._presences=new Map,this._users=new Map}connectionIds(){return this._connections.keys()}_toImmutable(){return ot(Array.from(this._presences.keys()).map(e=>this.getUser(Number(e))))}clearOthers(){this._connections=new Map,this._presences=new Map,this._users=new Map,this.invalidate()}_getUser(t){const e=this._connections.get(t),n=this._presences.get(t);if(e!==void 0&&n!==void 0)return Vr(e,n)}getUser(t){const e=this._users.get(t);if(e)return e;const n=this._getUser(t);if(n)return this._users.set(t,n),n}_invalidateUser(t){this._users.has(t)&&this._users.delete(t),this.invalidate()}setConnection(t,e,n,s){this._connections.set(t,ee({connectionId:t,id:e,info:n,scopes:s})),this._presences.has(t)&&this._invalidateUser(t)}removeConnection(t){this._connections.delete(t),this._presences.delete(t),this._invalidateUser(t)}setOther(t,e){this._presences.set(t,ee(ze(e))),this._connections.has(t)&&this._invalidateUser(t)}patchOther(t,e){const n=this._presences.get(t);if(n===void 0)return;const s=Dn(n,e);n!==s&&(this._presences.set(t,ee(s)),this._invalidateUser(t))}},Wr=class extends Ge{constructor(t){super(),this._data=ee(ze(t))}_toImmutable(){return this._data}patch(t){const e=this._data,n=Dn(e,t);e!==n&&(this._data=ee(n),this.invalidate())}},Zt=class extends Ge{constructor(t){super(),this._value=ee(t)}_toImmutable(){return this._value}set(t){this._value=ee(t),this.invalidate()}},st=class extends Ge{constructor(...t){super();const e=t.pop(),n=t;this._refs=n,this._refs.forEach(s=>{s.didInvalidate.subscribe(()=>this.invalidate())}),this._transform=e}_toImmutable(){return this._transform(...this._refs.map(t=>t.current))}},Br=1024*1024-1024;function Jr(t){let e=0;return()=>`${t}:${e++}`}function en(t,e){return{type:"User",id:`${e.connectionId}`,key:t,payload:{connectionId:e.connectionId,id:e.id,info:e.info,presence:e.presence,isReadOnly:!e.canWrite}}}function Gr(){const t=typeof document<"u"?document:void 0,e={current:null};function n(){(t==null?void 0:t.visibilityState)==="hidden"?e.current=e.current??Date.now():e.current=null}return t==null||t.addEventListener("visibilitychange",n),[e,()=>{t==null||t.removeEventListener("visibilitychange",n)}]}var pt=class extends Error{constructor(t,e,n){super(t),this.message=t,this.status=e,this.details=n}};function Yr(t,e,n){async function s(y,b,S){const f=await e();return n(t,y,f,S,b)}async function r(y,b,S){const f=await s(y,S,b);if(!f.ok&&f.status>=400&&f.status<600){let T;try{const K=await f.json();T=new pt(K.message,f.status,K)}catch{T=new pt(f.statusText,f.status)}throw T}let h;try{h=await f.json()}catch{h={}}return h}async function i(y){var f;let b;y!=null&&y.query&&(b=jr(y.query));const S=await s("/threads",{since:(f=y==null?void 0:y.since)==null?void 0:f.toISOString(),query:b},{headers:{"Content-Type":"application/json"}});if(S.ok){const h=await S.json();return{threads:h.data.map(T=>He(T)),inboxNotifications:h.inboxNotifications.map(T=>dt(T)),deletedThreads:h.deletedThreads.map(T=>Sn(T)),deletedInboxNotifications:h.deletedInboxNotifications.map(T=>Tn(T)),meta:{requestedAt:new Date(h.meta.requestedAt)}}}else{if(S.status===404)return{threads:[],inboxNotifications:[],deletedThreads:[],deletedInboxNotifications:[],meta:{requestedAt:new Date}};throw new Error("There was an error while getting threads.")}}async function a({threadId:y}){const b=await s(`/thread-with-notification/${y}`);if(b.ok){const S=await b.json();return{thread:He(S.thread),inboxNotification:S.inboxNotification?dt(S.inboxNotification):void 0}}else{if(b.status===404)return;throw new Error(`There was an error while getting thread ${y}.`)}}async function c({metadata:y,body:b,commentId:S,threadId:f}){const h=await r("/threads",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:f,comment:{id:S,body:b},metadata:y})});return He(h)}async function o({threadId:y}){await r(`/threads/${encodeURIComponent(y)}`,{method:"DELETE"})}async function d({metadata:y,threadId:b}){return await r(`/threads/${encodeURIComponent(b)}/metadata`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(y)})}async function m({threadId:y,commentId:b,body:S}){const f=await r(`/threads/${encodeURIComponent(y)}/comments`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:b,body:S})});return ut(f)}async function _({threadId:y,commentId:b,body:S}){const f=await r(`/threads/${encodeURIComponent(y)}/comments/${encodeURIComponent(b)}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({body:S})});return ut(f)}async function g({threadId:y,commentId:b}){await r(`/threads/${encodeURIComponent(y)}/comments/${encodeURIComponent(b)}`,{method:"DELETE"})}async function E({threadId:y,commentId:b,emoji:S}){const f=await r(`/threads/${encodeURIComponent(y)}/comments/${encodeURIComponent(b)}/reactions`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({emoji:S})});return cr(f)}async function w({threadId:y,commentId:b,emoji:S}){await r(`/threads/${encodeURIComponent(y)}/comments/${encodeURIComponent(b)}/reactions/${encodeURIComponent(S)}`,{method:"DELETE"})}return{getThreads:i,getThread:a,createThread:c,deleteThread:o,editThreadMetadata:d,createComment:m,editComment:_,deleteComment:g,addReaction:E,removeReaction:w}}var qr=50;function Xr(t,e){const n=t.initialPresence,s=t.initialStorage,[r,i]=Gr(),a={...e.delegates,canZombie(){return e.backgroundKeepAliveTimeout!==void 0&&r.current!==null&&Date.now()>r.current+e.backgroundKeepAliveTimeout&&Ne()!=="synchronizing"}},c=new Qs(a,e.enableDebugLogging),o={buffer:{flushTimerID:void 0,lastFlushedAt:0,presenceUpdates:{type:"full",data:n},messages:[],storageOperations:[]},staticSessionInfo:new Zt(null),dynamicSessionInfo:new Zt(null),myPresence:new Wr(n),others:new zr,initialStorage:s,idFactory:null,clock:0,opClock:0,nodes:new Map,root:void 0,undoStack:[],redoStack:[],pausedHistory:null,activeBatch:null,unacknowledgedOps:new Map,opStackTraces:void 0},d=u=>u(),m=e.unstable_batchedUpdates??d;let _;function g(u){const l=c.authValue;if(l!==null){const p=mt(l);if(p!==_)if(_=p,l.type==="secret"){const v=l.token.parsed;o.staticSessionInfo.set({userId:v.k==="sec-legacy"?v.id:v.uid,userInfo:v.k==="sec-legacy"?v.info:v.ui})}else o.staticSessionInfo.set({userId:void 0,userInfo:void 0})}m(()=>{h.status.notify(u),M(d)})}let E,w=!1;function y(u){u==="reconnecting"?E=setTimeout(()=>{m(()=>{h.lostConnection.notify("lost"),w=!0,o.others.clearOthers(),H({others:[{type:"reset"}]},d)})},e.lostConnectionTimeout):(clearTimeout(E),w&&(m(u==="disconnected"?()=>{h.lostConnection.notify("failed")}:()=>{h.lostConnection.notify("restored")}),w=!1))}function b(){o.buffer.presenceUpdates={type:"full",data:{...o.myPresence.current}},be!==null&&Pt({flush:!1}),V()}function S(){clearTimeout(o.buffer.flushTimerID)}c.events.onMessage.subscribe(ns),c.events.statusDidChange.subscribe(g),c.events.statusDidChange.subscribe(y),c.events.didConnect.subscribe(b),c.events.didDisconnect.subscribe(S),c.events.onLiveblocksError.subscribe(u=>{m(()=>{h.error.notify(u)})});const f={roomId:e.roomId,getNode:u=>o.nodes.get(u),addNode:(u,l)=>void o.nodes.set(u,l),deleteNode:u=>void o.nodes.delete(u),generateId:()=>`${ve()}:${o.clock++}`,generateOpId:()=>`${ve()}:${o.opClock++}`,dispatch(u,l,p){const v=o.activeBatch;if(v){for(const I of u)v.ops.push(I);for(const[I,O]of p)v.updates.storageUpdates.set(I,nt(v.updates.storageUpdates.get(I),O));v.reverseOps.unshift(...l)}else m(()=>{Ce(l,d),o.redoStack.length=0,At(u),H({storageUpdates:p},d)})},assertStorageIsWritable:()=>{var p;const u=(p=o.dynamicSessionInfo.current)==null?void 0:p.scopes;if(u===void 0)return;if(!at(u))throw new Error("Cannot write to storage with a read only user, please ensure the user has write permissions")}},h={status:P(),lostConnection:P(),customEvent:P(),self:P(),myPresence:P(),others:P(),error:P(),storageBatch:P(),history:P(),storageDidLoad:P(),storageStatus:P(),ydoc:P(),comments:P()};async function T(u,l,p,v,I){var j;const O=In(e.baseUrl,`/v2/c/rooms/${encodeURIComponent(u)}${l}`,I);return await(((j=e.polyfills)==null?void 0:j.fetch)||fetch)(O,{...v,headers:{...v==null?void 0:v.headers,Authorization:`Bearer ${mt(p)}`}})}async function K(u,l){return T(l,"/storage",u,{method:"GET",headers:{"Content-Type":"application/json"}})}async function D(u,l){if(!c.authValue)throw new Error("Not authorized");return T(e.roomId,u,c.authValue,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(l)})}async function $(u,l){if(!c.authValue)throw new Error("Not authorized");return T(e.roomId,"/text-mentions",c.authValue,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:u,mentionId:l})})}async function G(u){if(!c.authValue)throw new Error("Not authorized");return T(e.roomId,`/text-mentions/${u}`,c.authValue,{method:"DELETE"})}async function L(u,l){const p=await a.authenticate();return T(e.roomId,"/text-metadata",p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:u,rootKey:l})})}function A(u){var v;const l=JSON.stringify(u),p=(v=o.dynamicSessionInfo.current)==null?void 0:v.nonce;if(e.unstable_fallbackToHTTP&&p&&new TextEncoder().encode(l).length>Br){D("/send-message",{nonce:p,messages:u}).then(O=>{!O.ok&&O.status===403&&c.reconnect()}),B("Message was too large for websockets and sent over HTTP instead");return}c.send(l)}const R=new st(o.staticSessionInfo,o.dynamicSessionInfo,o.myPresence,(u,l,p)=>{if(u===null||l===null)return null;{const v=at(l.scopes);return{connectionId:l.actor,id:u.userId,info:u.userInfo,presence:p,canWrite:v,canComment:wn(l.scopes)}}});let U;function M(u){const l=R.current;l!==null&&l!==U&&(u(()=>{h.self.notify(l)}),U=l)}const Y=new st(R,u=>u!==null?en("Me",u):null);function se(u,l){var I;if(u.items.length===0)throw new Error("Internal error: cannot load storage without items");o.root!==void 0?Ae(u.items,l):o.root=de._fromItems(u.items,f);const p=((I=R.current)==null?void 0:I.canWrite)??!0,v=o.undoStack.length;for(const O in o.initialStorage)o.root.get(O)===void 0&&(p?o.root.set(O,Nr(o.initialStorage[O])):B(`Attempted to populate missing storage key '${O}', but current user has no write access`));o.undoStack.length=v}function Ae(u,l){if(o.root===void 0)return;const p=new Map;for(const[O,F]of o.nodes)p.set(O,F._serialize());const v=Rr(p,new Map(u)),I=ge(v,!1);H(I.updates,l)}function ye(u,l){o.undoStack.length>=50&&o.undoStack.shift(),o.undoStack.push(u),Qe(l)}function Ce(u,l){o.pausedHistory!==null?o.pausedHistory.unshift(...u):ye(u,l)}function H(u,l){const p=u.storageUpdates,v=u.others;l(()=>{if(v!==void 0&&v.length>0){const I=o.others.current;for(const O of v)h.others.notify({...O,others:I})}if((u.presence??!1)&&(M(d),h.myPresence.notify(o.myPresence.current)),p!==void 0&&p.size>0){const I=Array.from(p.values());h.storageBatch.notify(I)}Re()})}function ve(){const u=o.dynamicSessionInfo.current;if(u)return u.actor;throw new Error("Internal. Tried to get connection id but connection was never open")}function ge(u,l){const p={reverse:[],storageUpdates:new Map,presence:!1},v=new Set,I=u.map(O=>O.type!=="presence"&&!O.opId?{...O,opId:f.generateOpId()}:O);for(const O of I)if(O.type==="presence"){const F={type:"presence",data:{}};for(const j in O.data)F.data[j]=o.myPresence.current[j];if(o.myPresence.patch(O.data),o.buffer.presenceUpdates===null)o.buffer.presenceUpdates={type:"partial",data:O.data};else for(const j in O.data)o.buffer.presenceUpdates.data[j]=O.data[j];p.reverse.unshift(F),p.presence=!0}else{let F;if(l)F=0;else{const Le=k(O.opId);F=o.unacknowledgedOps.delete(Le)?2:1}const j=Gn(O,F);if(j.modified){const Le=j.modified.node._id;Le&&v.has(Le)||(p.storageUpdates.set(k(j.modified.node._id),nt(p.storageUpdates.get(k(j.modified.node._id)),j.modified)),p.reverse.unshift(...j.reverse)),(O.type===2||O.type===7||O.type===4)&&v.add(k(O.id))}}return{ops:I,reverse:p.reverse,updates:{storageUpdates:p.storageUpdates,presence:p.presence}}}function Gn(u,l){if(wr(u))return{modified:!1};switch(u.type){case 6:case 3:case 5:{const p=o.nodes.get(u.id);return p===void 0?{modified:!1}:p._apply(u,l===0)}case 1:{const p=o.nodes.get(u.id);return p===void 0?{modified:!1}:p.parent.type==="HasParent"&&Pn(p.parent.node)?p.parent.node._setChildKey(Ie(u.parentKey),p,l):{modified:!1}}case 4:case 2:case 7:case 8:{if(u.parentId===void 0)return{modified:!1};const p=o.nodes.get(u.parentId);return p===void 0?{modified:!1}:p._attachChild(u,l)}}}function Yn(u,l){const p={};o.buffer.presenceUpdates===null&&(o.buffer.presenceUpdates={type:"partial",data:{}});for(const v in u){const I=u[v];I!==void 0&&(o.buffer.presenceUpdates.data[v]=I,p[v]=o.myPresence.current[v])}o.myPresence.patch(u),o.activeBatch?(l!=null&&l.addToHistory&&o.activeBatch.reverseOps.unshift({type:"presence",data:p}),o.activeBatch.updates.presence=!0):(V(),m(()=>{l!=null&&l.addToHistory&&Ce([{type:"presence",data:p}],d),H({presence:!0},d)}))}function qn(u){if(u.targetActor!==void 0){const p=o.others.getUser(u.actor);o.others.setOther(u.actor,u.data);const v=o.others.getUser(u.actor);if(p===void 0&&v!==void 0)return{type:"enter",user:v}}else o.others.patchOther(u.actor,u.data);const l=o.others.getUser(u.actor);if(l)return{type:"update",updates:u.data,user:l}}function Xn(u){const l=o.others.getUser(u.actor);return l?(o.others.removeConnection(u.actor),{type:"leave",user:l}):null}function Qn(u,l){o.dynamicSessionInfo.set({actor:u.actor,nonce:u.nonce,scopes:u.scopes}),o.idFactory=Jr(u.actor),M(l);for(const p of o.others.connectionIds())u.users[p]===void 0&&o.others.removeConnection(p);for(const p in u.users){const v=u.users[p],I=Number(p);o.others.setConnection(I,v.id,v.info,v.scopes)}return{type:"reset"}}function It(){return o.undoStack.length>0}function Ot(){return o.redoStack.length>0}function Qe(u){u(()=>{h.history.notify({canUndo:It(),canRedo:Ot()})})}function Zn(u){o.others.setConnection(u.actor,u.id,u.info,u.scopes),o.buffer.messages.push({type:100,data:o.myPresence.current,targetActor:u.actor}),V();const l=o.others.getUser(u.actor);return l?{type:"enter",user:l}:void 0}function kt(u){return Mr(u)?u:null}function es(u){const l=yt(u);return l===void 0?null:Nn(l)?ot(l.map(p=>kt(p))):ot([kt(l)])}function ts(u,l){if(u.size===0)return;const p=[],v=Array.from(u.values()),I=ge(v,!0);p.push({type:201,ops:I.ops}),H(I.updates,l),A(p)}function ns(u){if(typeof u.data!="string")return;const l=es(u.data);if(l===null||l.length===0)return;const p={storageUpdates:new Map,others:[]};m(()=>{for(const v of l)switch(v.type){case 101:{const I=Zn(v);I&&p.others.push(I);break}case 100:{const I=qn(v);I&&p.others.push(I);break}case 103:{const I=o.others.current;h.customEvent.notify({connectionId:v.actor,user:v.actor<0?null:I.find(O=>O.connectionId===v.actor)??null,event:v.event});break}case 102:{const I=Xn(v);I&&p.others.push(I);break}case 300:{h.ydoc.notify(v);break}case 104:{p.others.push(Qn(v,d));break}case 200:{Ct(v);break}case 201:{const I=ge(v.ops,!1);for(const[O,F]of I.updates.storageUpdates)p.storageUpdates.set(O,nt(p.storageUpdates.get(O),F));break}case 299:{pn("Storage mutation rejection error",v.reason);break}case 400:case 407:case 401:case 405:case 406:case 402:case 403:case 404:{h.comments.notify(v);break}}H(p,d)})}function V(){const u=o.buffer.storageOperations;if(u.length>0){for(const v of u)o.unacknowledgedOps.set(k(v.opId),v);Re()}if(c.getStatus()!=="connected"){o.buffer.storageOperations=[];return}const l=Date.now(),p=l-o.buffer.lastFlushedAt;if(p>=e.throttleDelay){const v=ss();if(v.length===0)return;A(v),o.buffer={flushTimerID:void 0,lastFlushedAt:l,messages:[],storageOperations:[],presenceUpdates:null}}else clearTimeout(o.buffer.flushTimerID),o.buffer.flushTimerID=setTimeout(V,e.throttleDelay-p)}function ss(){const u=[];o.buffer.presenceUpdates&&u.push(o.buffer.presenceUpdates.type==="full"?{type:100,targetActor:-1,data:o.buffer.presenceUpdates.data}:{type:100,data:o.buffer.presenceUpdates.data});for(const l of o.buffer.messages)u.push(l);return o.buffer.storageOperations.length>0&&u.push({type:201,ops:o.buffer.storageOperations}),u}function rs(u,l){const p={type:301,update:u,guid:l};o.buffer.messages.push(p),h.ydoc.notify(p),V()}function is(u,l={shouldQueueEventIfNotReady:!1}){c.getStatus()!=="connected"&&!l.shouldQueueEventIfNotReady||(o.buffer.messages.push({type:103,event:u}),V())}function At(u){const{storageOperations:l}=o.buffer;for(const p of u)l.push(p);V()}let be=null,Pe=null;function Ct(u){const l=new Map(o.unacknowledgedOps);se(u,d),ts(l,d),Pe==null||Pe(),Re(),h.storageDidLoad.notify()}async function os(){if(!c.authValue)return;const l=await(await K(c.authValue,e.roomId)).json();Ct({type:200,items:l})}function Pt(u){const l=o.buffer.messages;e.unstable_streamData?os():l.some(p=>p.type===200)||l.push({type:200}),u.flush&&V()}function Nt(){return be===null&&(Pt({flush:!0}),be=new Promise(u=>{Pe=u}),Re()),be}function Rt(){const u=o.root;return u!==void 0?u:(Nt(),null)}async function Dt(){return o.root!==void 0?Promise.resolve({root:o.root}):(await Nt(),{root:k(o.root)})}function as(u,l){o.buffer.messages.find(p=>p.type===300&&p.vector===u&&p.guid===l)||o.buffer.messages.push({type:300,vector:u,guid:l}),V()}function cs(){if(o.activeBatch)throw new Error("undo is not allowed during a batch");const u=o.undoStack.pop();if(u===void 0)return;o.pausedHistory=null;const l=ge(u,!0);m(()=>{H(l.updates,d),o.redoStack.push(l.reverse),Qe(d)});for(const p of l.ops)p.type!=="presence"&&o.buffer.storageOperations.push(p);V()}function us(){if(o.activeBatch)throw new Error("redo is not allowed during a batch");const u=o.redoStack.pop();if(u===void 0)return;o.pausedHistory=null;const l=ge(u,!0);m(()=>{H(l.updates,d),o.undoStack.push(l.reverse),Qe(d)});for(const p of l.ops)p.type!=="presence"&&o.buffer.storageOperations.push(p);V()}function ds(){o.undoStack.length=0,o.redoStack.length=0}function ls(u){if(o.activeBatch)return u();let l;return m(()=>{o.activeBatch={ops:[],updates:{storageUpdates:new Map,presence:!1,others:[]},reverseOps:[]};try{l=u()}finally{const p=o.activeBatch;o.activeBatch=null,p.reverseOps.length>0&&Ce(p.reverseOps,d),p.ops.length>0&&(o.redoStack.length=0),p.ops.length>0&&At(p.ops),H(p.updates,d),V()}}),l}function fs(){o.pausedHistory===null&&(o.pausedHistory=[])}function hs(){const u=o.pausedHistory;o.pausedHistory=null,u!==null&&u.length>0&&ye(u,m)}function Ne(){return o.root===void 0?be===null?"not-loaded":"loading":o.unacknowledgedOps.size===0?"synchronized":"synchronizing"}let Lt=Ne();function Re(){const u=Ne();Lt!==u&&(Lt=u,h.storageStatus.notify(u))}function xt(){return R.current!==null}async function ps(){for(;!xt();){const{promise:u,resolve:l}=Ps(),p=De.self.subscribeOnce(l),v=De.status.subscribeOnce(l);await u,p(),v()}}function Ut(){return Rt()!==null}async function ms(){for(;!Ut();)await Dt()}const _s=new st(o.others,u=>u.map((l,p)=>en(`Other ${p}`,l))),De={status:h.status.observable,lostConnection:h.lostConnection.observable,customEvent:h.customEvent.observable,others:h.others.observable,self:h.self.observable,myPresence:h.myPresence.observable,error:h.error.observable,storage:h.storageBatch.observable,storageBatch:h.storageBatch.observable,history:h.history.observable,storageDidLoad:h.storageDidLoad.observable,storageStatus:h.storageStatus.observable,ydoc:h.ydoc.observable,comments:h.comments.observable},ys=Yr(e.roomId,a.authenticate,T);async function Ze(u,l){const p=await a.authenticate(),v=await T(e.roomId,u,p,l);if(!v.ok&&v.status>=400&&v.status<600){let O;try{const F=await v.json();O=new Oe(F.message,v.status,F)}catch{O=new Oe(v.statusText,v.status)}throw O}let I;try{I=await v.json()}catch{I={}}return I}function vs(){return Ze("/notification-settings")}function gs(u){return Ze("/notification-settings",{method:"POST",body:JSON.stringify(u),headers:{"Content-Type":"application/json"}})}async function bs(u){await Ze("/inbox-notifications/read",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inboxNotificationIds:u})})}const ws=new vt(async u=>{const l=u.flat();return await bs(l),l},{delay:qr});async function Es(u){await ws.get(u)}return Object.defineProperty({[Q]:{get presenceBuffer(){var u;return Te(((u=o.buffer.presenceUpdates)==null?void 0:u.data)??null)},get undoStack(){return Te(o.undoStack)},get nodeCount(){return o.nodes.size},reportTextEditor:L,createTextMention:$,deleteTextMention:G,getSelf_forDevTools:()=>Y.current,getOthers_forDevTools:()=>_s.current,simulate:{explicitClose:u=>c._privateSendMachineEvent({type:"EXPLICIT_SOCKET_CLOSE",event:u}),rawSend:u=>c.send(u)},comments:{...ys},notifications:{getRoomNotificationSettings:vs,updateRoomNotificationSettings:gs,markInboxNotificationAsRead:Es}},id:e.roomId,subscribe:Qr(De),connect:()=>c.connect(),reconnect:()=>c.reconnect(),disconnect:()=>c.disconnect(),destroy:()=>{i(),c.destroy()},updatePresence:Yn,updateYDoc:rs,broadcastEvent:is,batch:ls,history:{undo:cs,redo:us,canUndo:It,canRedo:Ot,clear:ds,pause:fs,resume:hs},fetchYDoc:as,getStorage:Dt,getStorageSnapshot:Rt,getStorageStatus:Ne,isPresenceReady:xt,isStorageReady:Ut,waitUntilPresenceReady:$t(ps),waitUntilStorageReady:$t(ms),events:De,getStatus:()=>c.getStatus(),getSelf:()=>R.current,getPresence:()=>o.myPresence.current,getOthers:()=>o.others.current},Q,{enumerable:!1})}function Qr(t){function e(r,i){return t.storageBatch.subscribe(a=>{const c=a.filter(o=>An(o.node,r));c.length>0&&i(c)})}function n(r,i){return t.storageBatch.subscribe(a=>{for(const c of a)c.node._id===r._id&&i(c.node)})}function s(r,i,a){if(typeof r=="string"&&Zr(r)){if(typeof i!="function")throw new Error("Second argument must be a callback function");const c=i;switch(r){case"event":return t.customEvent.subscribe(c);case"my-presence":return t.myPresence.subscribe(c);case"others":{const o=c;return t.others.subscribe(d=>{const{others:m,..._}=d;return o(m,_)})}case"error":return t.error.subscribe(c);case"status":return t.status.subscribe(c);case"lost-connection":return t.lostConnection.subscribe(c);case"history":return t.history.subscribe(c);case"storage-status":return t.storageStatus.subscribe(c);default:return X(r,`"${String(r)}" is not a valid event name`)}}if(i===void 0||typeof r=="function")if(typeof r=="function"){const c=r;return t.storageBatch.subscribe(c)}else throw new Error("Please specify a listener callback");if(x(r)){const c=r;return a!=null&&a.isDeep?e(c,i):n(c,i)}throw new Error(`${String(r)} is not a value that can be subscribed to.`)}return s}function Zr(t){return t==="my-presence"||t==="others"||t==="event"||t==="error"||t==="history"||t==="status"||t==="storage-status"||t==="lost-connection"||t==="connection"}function ei(t,e){return async()=>e.getAuthValue({requestedScope:"room:read",roomId:t})}function ti(t,e,n){return s=>{const r=n??(typeof WebSocket>"u"?void 0:WebSocket);if(r===void 0)throw new ie("To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.");const i=new URL(e);if(i.protocol=i.protocol==="http:"?"ws":"wss",i.pathname="/v7",i.searchParams.set("roomId",t),s.type==="secret")i.searchParams.set("tok",s.token.raw);else if(s.type==="public")i.searchParams.set("pubkey",s.publicApiKey);else return X(s,"Unhandled case");return i.searchParams.set("version",cn),new r(i.toString())}}function ni(){const t=En({threads:{},queries:{},optimisticUpdates:[],inboxNotifications:{},notificationSettings:{}}),e=P();return{...t,deleteThread(n){t.set(s=>({...s,threads:si(s.threads,n),inboxNotifications:Object.fromEntries(Object.entries(s.inboxNotifications).filter(([r,i])=>i.kind==="thread"&&i.threadId===n))}))},updateThreadAndNotification(n,s){t.set(r=>{const i=r.threads[n.id];return{...r,threads:i===void 0||Ln(n,i)===1?{...r.threads,[n.id]:n}:r.threads,inboxNotifications:s===void 0?r.inboxNotifications:{...r.inboxNotifications,[s.id]:s}}})},updateThreadsAndNotifications(n,s,r,i,a){t.set(c=>({...c,threads:ri(c.threads,{newThreads:n,deletedThreads:r}),inboxNotifications:ii(c.inboxNotifications,{newInboxNotifications:s,deletedNotifications:i}),queries:a!==void 0?{...c.queries,[a]:{isLoading:!1}}:c.queries}))},updateRoomInboxNotificationSettings(n,s,r){t.set(i=>({...i,notificationSettings:{...i.notificationSettings,[n]:s},queries:{...i.queries,[r]:{isLoading:!1}}}))},pushOptimisticUpdate(n){e.notify(n),t.set(s=>({...s,optimisticUpdates:[...s.optimisticUpdates,n]}))},setQueryState(n,s){t.set(r=>({...r,queries:{...r.queries,[n]:s}}))},optimisticUpdatesEventSource:e}}function si(t,e){if(Object.prototype.hasOwnProperty.call(t,e)){const{[e]:n,...s}=t;return s}return t}function Ln(t,e){return t.updatedAt&&e.updatedAt?t.updatedAt>e.updatedAt?1:t.updatedAt<e.updatedAt?-1:0:t.updatedAt||e.updatedAt?t.updatedAt?1:-1:t.createdAt>e.createdAt?1:t.createdAt<e.createdAt?-1:0}function ri(t,e){const n={...t};return e.newThreads.forEach(s=>{const r=n[s.id];r&&Ln(r,s)===1||(n[s.id]=s)}),e.deletedThreads.forEach(({id:s,deletedAt:r})=>{const i=n[s];i!==void 0&&(i.deletedAt=r,i.updatedAt=r,i.comments=[])}),n}function ii(t,e){const n={...t};return e.newInboxNotifications.forEach(s=>{const r=n[s.id];r&&oi(r,s)===1||(n[s.id]=s)}),e.deletedNotifications.forEach(({id:s})=>delete n[s]),n}function oi(t,e){return t.notifiedAt>e.notifiedAt?1:t.notifiedAt<e.notifiedAt?-1:t.readAt&&e.readAt?t.readAt>e.readAt?1:t.readAt<e.readAt?-1:0:t.readAt||e.readAt?t.readAt?1:-1:0}var ai=16,ci=1e3,ui=100,di=15e3,li=200,fi=1e3,hi=3e4,pi=5e3,mi=50,_i=50;function yi(t){return typeof t=="string"&&t.startsWith("http")?t:sr}function mt(t){return t.type==="public"?t.publicApiKey:t.token.raw}function vi(t){var L;const e=t,n=bi(e.throttle??ui),s=wi(e.lostConnectionTimeout??pi),r=gi(e.backgroundKeepAliveTimeout),i=yi(e.baseUrl),a=er(t),c=new Map;function o(A){A.id,c.delete(A.id),A.destroy()}function d(A){const R=()=>{const U=R;A.unsubs.delete(U)?A.unsubs.size===0&&o(A.room):B("This leave function was already called. Calling it more than once has no effect.")};return A.unsubs.add(R),{room:A.room,leave:R}}function m(A,...R){var H,ve;const U=c.get(A);if(U!==void 0)return d(U);const M=R[0]??{},Y=(typeof M.initialPresence=="function"?M.initialPresence(A):M.initialPresence)??{},se=(typeof M.initialStorage=="function"?M.initialStorage(A):M.initialStorage)??{},Ae=Xr({initialPresence:Y,initialStorage:se},{roomId:A,throttleDelay:n,lostConnectionTimeout:s,backgroundKeepAliveTimeout:r,polyfills:e.polyfills,delegates:e.mockedDelegates??{createSocket:ti(A,i,(H=e.polyfills)==null?void 0:H.WebSocket),authenticate:ei(A,a)},enableDebugLogging:e.enableDebugLogging,unstable_batchedUpdates:M==null?void 0:M.unstable_batchedUpdates,baseUrl:i,unstable_fallbackToHTTP:!!e.unstable_fallbackToHTTP,unstable_streamData:!!e.unstable_streamData}),ye={room:Ae,unsubs:new Set};if(c.set(A,ye),M.autoConnect??!0){if(typeof atob>"u"){if(((ve=e.polyfills)==null?void 0:ve.atob)===void 0)throw new Error("You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill");global.atob=e.polyfills.atob}Ae.connect()}return d(ye)}function _(A){var U;const R=(U=c.get(A))==null?void 0:U.room;return R||null}function g(){a.reset();for(const{room:A}of c.values())Fs(A.getStatus())||A.reconnect()}const E=En(null),{getInboxNotifications:w,getUnreadInboxNotificationsCount:y,markAllInboxNotificationsAsRead:b,markInboxNotificationAsRead:S}=lr({baseUrl:i,fetcher:((L=e.polyfills)==null?void 0:L.fetch)||fetch,authManager:a,currentUserIdStore:E}),f=ni(),h=e.resolveUsers,T=tn(()=>!h,"Set the resolveUsers option in createClient to specify user info."),K=Wt(async A=>{const R=A.flat(),U=await(h==null?void 0:h({userIds:R}));return T(),U??R.map(()=>{})},{delay:mi}),D=e.resolveRoomsInfo,$=tn(()=>!D,"Set the resolveRoomsInfo option in createClient to specify room info."),G=Wt(async A=>{const R=A.flat(),U=await(D==null?void 0:D({roomIds:R}));return $(),U??R.map(()=>{})},{delay:_i});return Object.defineProperty({enterRoom:m,getRoom:_,logout:g,[Q]:{notifications:{getInboxNotifications:w,getUnreadInboxNotificationsCount:y,markAllInboxNotificationsAsRead:b,markInboxNotificationAsRead:S},currentUserIdStore:E,resolveMentionSuggestions:e.resolveMentionSuggestions,cacheStore:f,usersStore:K,roomsInfoStore:G,getRoomIds(){return Array.from(c.keys())}}},Q,{enumerable:!1})}var Oe=class extends Error{constructor(t,e,n){super(t),this.message=t,this.status=e,this.details=n}};function wt(t,e,n,s,r){if(typeof e!="number"||e<n||s!==void 0&&e>s)throw new Error(s!==void 0?`${t} should be between ${r??n} and ${s}.`:`${t} should be at least ${r??n}.`);return e}function gi(t){if(t!==void 0)return wt("backgroundKeepAliveTimeout",t,di)}function bi(t){return wt("throttle",t,ai,ci)}function wi(t){return wt("lostConnectionTimeout",t,li,hi,fi)}function tn(t,...e){return()=>{}}var Ei={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};new RegExp(Object.keys(Ei).map(t=>`\\${t}`).join("|"),"g");var Si={_:"\\_","*":"\\*","#":"\\#","`":"\\`","~":"\\~","!":"\\!","|":"\\|","(":"\\(",")":"\\)","{":"\\{","}":"\\}","[":"\\[","]":"\\]"};new RegExp(Object.keys(Si).map(t=>`\\${t}`).join("|"),"g");function Ti(t){let e={state:"stopped",timeoutHandle:null,interval:null,lastScheduledAt:null,remainingInterval:null};function n(){e.state==="running"&&s(e.interval),t()}function s(m){e={state:"running",interval:e.state!=="stopped"?e.interval:m,lastScheduledAt:performance.now(),timeoutHandle:setTimeout(n,m),remainingInterval:null}}function r(m){e.state==="paused"&&(e={state:"running",interval:e.interval,lastScheduledAt:e.lastScheduledAt,timeoutHandle:setTimeout(n,m),remainingInterval:null})}function i(m){e.state!=="running"&&s(m)}function a(m){d(),i(m)}function c(){e.state==="running"&&(clearTimeout(e.timeoutHandle),e={state:"paused",interval:e.interval,lastScheduledAt:e.lastScheduledAt,timeoutHandle:null,remainingInterval:e.interval-(performance.now()-e.lastScheduledAt)})}function o(){e.state==="paused"&&r(e.remainingInterval)}function d(){e.state!=="stopped"&&(e.timeoutHandle&&clearTimeout(e.timeoutHandle),e={state:"stopped",interval:null,lastScheduledAt:null,timeoutHandle:null,remainingInterval:null})}return{start:i,restart:a,pause:c,resume:o,stop:d}}function Ii(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!Object.is(t[n],e[n]))return!1;return!0}function Oi(t,e){if(typeof t!="object"||t===null||typeof e!="object"||e===null||Object.prototype.toString.call(t)!=="[object Object]"||Object.prototype.toString.call(e)!=="[object Object]")return!1;const n=Object.keys(t);return n.length!==Object.keys(e).length?!1:n.every(s=>Object.prototype.hasOwnProperty.call(e,s)&&Object.is(t[s],e[s]))}function ki(t,e){if(Object.is(t,e))return!0;const n=Array.isArray(t),s=Array.isArray(e);return n||s?!n||!s?!1:Ii(t,e):Oi(t,e)}Ve(Is,cn,Os);var xn={exports:{}},Un={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _e=C;function Ai(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var Ci=typeof Object.is=="function"?Object.is:Ai,Pi=_e.useState,Ni=_e.useEffect,Ri=_e.useLayoutEffect,Di=_e.useDebugValue;function Li(t,e){var n=e(),s=Pi({inst:{value:n,getSnapshot:e}}),r=s[0].inst,i=s[1];return Ri(function(){r.value=n,r.getSnapshot=e,rt(r)&&i({inst:r})},[t,n,e]),Ni(function(){return rt(r)&&i({inst:r}),t(function(){rt(r)&&i({inst:r})})},[t]),Di(n),n}function rt(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!Ci(t,n)}catch{return!0}}function xi(t,e){return e()}var Ui=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?xi:Li;Un.useSyncExternalStore=_e.useSyncExternalStore!==void 0?_e.useSyncExternalStore:Ui;xn.exports=Un;var Mi=xn.exports,Mn={exports:{}},$n={};/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ye=C,$i=Mi;function ji(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var Ki=typeof Object.is=="function"?Object.is:ji,Fi=$i.useSyncExternalStore,Hi=Ye.useRef,Vi=Ye.useEffect,zi=Ye.useMemo,Wi=Ye.useDebugValue;$n.useSyncExternalStoreWithSelector=function(t,e,n,s,r){var i=Hi(null);if(i.current===null){var a={hasValue:!1,value:null};i.current=a}else a=i.current;i=zi(function(){function o(E){if(!d){if(d=!0,m=E,E=s(E),r!==void 0&&a.hasValue){var w=a.value;if(r(w,E))return _=w}return _=E}if(w=_,Ki(m,E))return w;var y=s(E);return r!==void 0&&r(w,y)?w:(m=E,_=y)}var d=!1,m,_,g=n===void 0?null:n;return[function(){return o(e())},g===null?void 0:function(){return o(g())}]},[e,n,s,r]);var c=Fi(t,i[0],i[1]);return Vi(function(){a.hasValue=!0,a.value=c},[c]),Wi(c),c};Mn.exports=$n;var qe=Mn.exports,Bi="@liveblocks/client",Ji="2.1.0",Gi="esm";Ve(Bi,Ji,Gi);var jn="@liveblocks/react",Kn="2.1.0",Fn="esm";function Yi(t){const[e,n]=C.useState(!1);return C.useEffect(()=>{n(!0)},[]),C.createElement(C.Suspense,{fallback:t.fallback},e?typeof t.children=="function"?t.children():t.children:t.fallback)}var qi=5,Xi=5e3;function nn(t,e){if(e>=qi)return;const n=Math.pow(2,e)*Xi;setTimeout(()=>{t()},n)}function Qi(t){const e=C.useRef(t);return C.useEffect(()=>{e.current=t},[t]),e}var Zi=t=>t;function z(t){return C.useReducer(Zi,t)[0]}function Ke(t){const e=z(t);if(typeof e=="function"){const n=Qi(t);return C.useCallback((...s)=>n.current(...s),[n])}else return e}var Hn=C.createContext(null);function eo(t){const e=Vn();if(!(t!=null&&t.allowNesting)&&e!==null)throw new Error("You cannot nest multiple LiveblocksProvider instances in the same React tree.")}function Vn(){return C.useContext(Hn)}function zn(){return console.log("xxxx"),Vn()??$s("LiveblocksProvider is missing from the React tree.")}function to(t){return eo(t),an.createElement(Hn.Provider,{value:t.client},t.children)}function Ro(t){const{children:e,...n}=t,s={publicApiKey:z(n.publicApiKey),throttle:z(n.throttle),lostConnectionTimeout:z(n.lostConnectionTimeout),backgroundKeepAliveTimeout:z(n.backgroundKeepAliveTimeout),polyfills:z(n.polyfills),unstable_fallbackToHTTP:z(n.unstable_fallbackToHTTP),unstable_streamData:z(n.unstable_streamData),authEndpoint:Ke(n.authEndpoint),resolveMentionSuggestions:Ke(n.resolveMentionSuggestions),resolveUsers:Ke(n.resolveUsers),resolveRoomsInfo:Ke(n.resolveRoomsInfo),baseUrl:z(n.baseUrl),enableDebugLogging:z(n.enableDebugLogging)},r=C.useMemo(()=>vi(s),[]);return an.createElement(to,{client:r},e)}var Wn=t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)},no=()=>{},Et=t=>t;function St(t,e,n){return qe.useSyncExternalStoreWithSelector(t,e,n,Et)}var so=Object.freeze([]),sn=5*60*1e3;function ro(){return so}function Tt(){return null}function io(t){return t.map(e=>e.connectionId)}function oo(t){const e="This mutation cannot be used until",n=`${e} connected to the Liveblocks room`,s=`${e} storage has been loaded`;return{get storage(){const r=t.getStorageSnapshot();if(r===null)throw new Error(s);return r},get self(){const r=t.getSelf();if(r===null)throw new Error(n);return r},get others(){const r=t.getOthers();if(t.getSelf()===null)throw new Error(n);return r},setMyPresence:t.updatePresence}}function rn(t){var n;const e=`Request failed with status ${t.status}: ${t.message}`;if(((n=t.details)==null?void 0:n.error)==="FORBIDDEN"){const s=[e,t.details.suggestion,t.details.docs].filter(Boolean).join(`
`);_t.error(s)}return new Error(e)}var on=new WeakMap;function it(t){let e=on.get(t);return e||(e=ao(t),on.set(t,e)),e}function ao(t){const e=t[Q].cacheStore,n=2e3,s=new Map,r=new Map,i=new Map,a=new Map,c=Ti(o);async function o(){const y=[];t[Q].getRoomIds().map(b=>{const S=t.getRoom(b);S!==null&&y.push(m(S.id))}),await Promise.allSettled(y)}function d(y){const b=a.get(y)??0;return a.set(y,b+1),c.start(sn),()=>{const S=a.get(y);if(S===void 0||S<=0){_t.warn(`Internal unexpected behavior. Cannot decrease subscriber count for query "${y}"`);return}a.set(y,S-1);let f=0;for(const h of a.values())f+=h;f<=0&&c.stop()}}async function m(y){const b=t.getRoom(y);if(b===null)return;const S=s.get(b.id);if(!(S===void 0||(i.get(b.id)??!1)===!0))try{i.set(b.id,!0);const T=await b[Q].comments.getThreads({since:S});setTimeout(()=>{i.set(b.id,!1)},n),e.updateThreadsAndNotifications(T.threads,T.inboxNotifications,T.deletedThreads,T.deletedInboxNotifications),s.set(b.id,T.meta.requestedAt)}catch{i.set(b.id,!1);return}}async function _(y,b,S,{retryCount:f}={retryCount:0}){const h=r.get(b);if(h!==void 0)return h;const K=y[Q].comments.getThreads(S);r.set(b,K),e.setQueryState(b,{isLoading:!0});try{const D=await K;e.updateThreadsAndNotifications(D.threads,D.inboxNotifications,D.deletedThreads,D.deletedInboxNotifications,b);const $=s.get(y.id);($===void 0||$>D.meta.requestedAt)&&s.set(y.id,D.meta.requestedAt),c.start(sn)}catch(D){r.delete(b),nn(()=>{_(y,b,S,{retryCount:f+1})},f),e.setQueryState(b,{isLoading:!1,error:D})}}async function g(y,b,{retryCount:S}={retryCount:0}){const f=r.get(b);if(f!==void 0)return f;try{const h=y[Q].notifications.getRoomNotificationSettings();r.set(b,h),e.setQueryState(b,{isLoading:!0});const T=await h;e.updateRoomInboxNotificationSettings(y.id,T,b)}catch(h){r.delete(b),nn(()=>{g(y,b,{retryCount:S+1})},S),e.setQueryState(b,{isLoading:!1,error:h})}}const E=P();function w(y,b,S){if(e.set(f=>({...f,optimisticUpdates:f.optimisticUpdates.filter(h=>h.id!==b)})),y instanceof pt){const f=rn(y);E.notify(S(f));return}if(y instanceof Oe){rn(y);return}throw y}return{store:e,incrementQuerySubscribers:d,commentsErrorEventSource:E,getThreadsUpdates:m,getThreadsAndInboxNotifications:_,getInboxNotificationSettings:g,onMutationFailure:w}}var Bn=C.createContext(null);function co(t){const e=zn(),[n]=C.useState(()=>new Map),s=C.useCallback((r,i)=>{const a=n.get(r);if(a)return a;const c=e.enterRoom(r,i),o=c.leave;return c.leave=()=>{o(),n.delete(r)},n.set(r,c),c},[e,n]);return C.createElement(uo,{...t,stableEnterRoom:s})}function uo(t){const e=zn(),{id:n,stableEnterRoom:s}=t,r=z({initialPresence:t.initialPresence,initialStorage:t.initialStorage,unstable_batchedUpdates:t.unstable_batchedUpdates,autoConnect:t.autoConnect??typeof window<"u"}),[{room:i},a]=C.useState(()=>s(n,{...r,autoConnect:!1}));return C.useEffect(()=>{const{store:c}=it(e);async function o(d){if(d.type===te.THREAD_DELETED){c.deleteThread(d.threadId);return}const m=await i[Q].comments.getThread({threadId:d.threadId});if(!m){c.deleteThread(d.threadId);return}const{thread:_,inboxNotification:g}=m,E=c.get().threads[d.threadId];switch(d.type){case te.COMMENT_EDITED:case te.THREAD_METADATA_UPDATED:case te.COMMENT_REACTION_ADDED:case te.COMMENT_REACTION_REMOVED:case te.COMMENT_DELETED:if(!E)break;c.updateThreadAndNotification(_,g);break;case te.COMMENT_CREATED:c.updateThreadAndNotification(_,g);break}}return i.events.comments.subscribe(d=>void o(d))},[e,i]),C.useEffect(()=>{const{getThreadsUpdates:c}=it(e);c(i.id)},[e,i.id]),C.useEffect(()=>{function c(){const{getThreadsUpdates:o}=it(e);o(i.id)}return window.addEventListener("online",c),()=>{window.removeEventListener("online",c)}},[e,i.id]),C.useEffect(()=>{const c=s(n,r);a(c);const{room:o,leave:d}=c;return r.autoConnect&&o.connect(),()=>{d()}},[n,r,s]),C.createElement(Bn.Provider,{value:i},t.children)}function J(){const t=To();if(t===null)throw new Error("RoomProvider is missing from the React tree.");return t}function Do(){return J().history}function Lo(){const t=J(),e=t.events.history.subscribe,n=t.history.canUndo;return St(e,n,n)}function xo(){const t=J(),e=t.events.history.subscribe,n=t.history.canRedo;return St(e,n,n)}function lo(t,e){const n=J(),s=n.events.self.subscribe,r=n.getSelf,i=t??Et,a=C.useCallback(o=>o!==null?i(o):null,[i]),c=Tt;return qe.useSyncExternalStoreWithSelector(s,r,c,a,e)}function Xe(t,e){const n=J(),s=n.events.others.subscribe,r=n.getOthers,i=ro;return qe.useSyncExternalStoreWithSelector(s,r,i,t??Et,e)}function fo(t,e){const n=C.useCallback(r=>r.map(i=>[i.connectionId,t(i)]),[t]),s=C.useCallback((r,i)=>{const a=e??Object.is;return r.length===i.length&&r.every((c,o)=>{const d=i[o];return c[0]===d[0]&&a(c[1],d[1])})},[e]);return Xe(n,s)}function ho(){return Xe(io,ki)}var Fe=Symbol();function po(t,e,n){const s=C.useCallback(a=>{const c=a.find(o=>o.connectionId===t);return c!==void 0?e(c):Fe},[t,e]),r=C.useCallback((a,c)=>a===Fe||c===Fe?a===c:(n??Object.is)(a,c),[n]),i=Xe(s,r);if(i===Fe)throw new Error(`No such other user with connection id ${t} exists`);return i}function mo(){const t=J(),e=t.events.storageDidLoad.subscribeOnce,n=t.getStorageSnapshot;return St(e,n,Tt)}function _o(t,e){const n=J(),s=mo(),r=C.useCallback(o=>o!==null?t(o):null,[t]),i=C.useCallback(o=>s!==null?n.subscribe(s,o,{isDeep:!0}):no,[n,s]),a=C.useCallback(()=>s===null?null:s.toImmutable(),[s]),c=Tt;return qe.useSyncExternalStoreWithSelector(i,a,c,r,e)}function yo(t,e){const n=J();return C.useMemo(()=>(...s)=>n.batch(()=>t(oo(n),...s)),[n,...e])}function Jn(){if(typeof window>"u")throw new Error(`You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.
For tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr`)}function ke(){Jn();const t=J();Wn(t.waitUntilPresenceReady())}function vo(t,e){return ke(),lo(t,e)}function go(t,e){return ke(),Xe(t,e)}function Uo(){return ke(),ho()}function bo(t,e){return ke(),fo(t,e)}function wo(t,e,n){return ke(),po(t,e,n)}function Eo(){Jn();const t=J();Wn(t.waitUntilStorageReady())}function So(t,e){return Eo(),_o(t,e)}function To(){return C.useContext(Bn)}var Io=co,Mo=J,$o=yo,jo=bo,Ko=wo;function Fo(...t){return go(...t)}var Ho=So;function Vo(...t){return vo(...t)}Ve(jn,Kn,Fn);Ve(jn,Kn,Fn);const Oo="_loading_8n4kt_1",ko={loading:Oo};function Ao(){return Se.jsx("div",{className:ko.loading,children:Se.jsx("img",{src:"https://liveblocks.io/loading.svg",alt:"Loading"})})}function zo({children:t,roomID:e}){return Se.jsx(Io,{id:e,initialPresence:{selection:[],cursor:null,pencilDraft:null,penColor:null},initialStorage:{layers:new ue,layerIds:new ce([])},children:Se.jsx(Yi,{fallback:Se.jsx(Ao,{}),children:t})})}export{Hr as C,de as L,zo as R,Vo as _,Ho as a,$o as b,Ko as c,jo as d,Do as e,Lo as f,xo as g,Ro as h,Ve as i,Mo as j,Fo as k,ki as s,Uo as u};
//# sourceMappingURL=Room.Dup0VRTS.js.map

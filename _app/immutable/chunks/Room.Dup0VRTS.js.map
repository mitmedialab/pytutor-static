{"version":3,"file":"Room.Dup0VRTS.js","sources":["../../../../../../node_modules/@liveblocks/core/dist/index.mjs","../../../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../../../../../../node_modules/use-sync-external-store/shim/index.js","../../../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../../../../../../node_modules/use-sync-external-store/shim/with-selector.js","../../../../../../node_modules/@liveblocks/client/dist/index.mjs","../../../../../../node_modules/@liveblocks/react/dist/chunk-D4UC2JLP.mjs","../../../../../../node_modules/@liveblocks/react/dist/suspense.mjs","../../../../../../node_modules/@liveblocks/react/dist/index.mjs","../../../../../../src/lib/shared/Loading.tsx","../../../../../../src/lib/shared/Room.tsx"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.1.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (process.env.NODE_ENV === \"production\") {\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function clear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    clear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern The state name, or state group pattern name.\n   * @param after          Number of milliseconds after which to take the\n   *                       transition. If in the mean time, another transition\n   *                       is taken, the timer will get cancelled.\n   * @param target     The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return this.allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoize(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = { value: factoryFn() };\n    }\n    return cached.value;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch2, endpoint, body) {\n  const res = await fetch2(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_DELAY = 100;\nvar noop = () => {\n};\nvar BatchCall = class {\n  constructor(args) {\n    this.resolve = noop;\n    this.reject = noop;\n    this.promise = new Promise(noop);\n    this.args = args;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = options?.size ?? DEFAULT_SIZE;\n    this.delay = options?.delay ?? DEFAULT_DELAY;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const args = calls.map((call) => call.args);\n    try {\n      const results = await this.callback(args);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(...args) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.args) === stringify(args)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(args);\n    call.promise = new Promise((resolve, reject) => {\n      call.resolve = resolve;\n      call.reject = reject;\n    });\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(callback, options) {\n  const batch = new Batch(callback, options);\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    if (state) {\n      cache.set(cacheKey, state);\n    } else {\n      cache.delete(cacheKey);\n    }\n    eventSource2.notify(state);\n  }\n  async function get(...args) {\n    const cacheKey = getCacheKey(args);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(...args);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(...args) {\n    const cacheKey = getCacheKey(args);\n    return cache.get(cacheKey);\n  }\n  return {\n    ...eventSource2,\n    get,\n    getState\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const newState = callback(state);\n    if (state === newState) {\n      return;\n    }\n    state = newState;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    callback(state);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const updatedAt = data.updatedAt ? new Date(data.updatedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url.toString();\n}\n\n// src/notifications.ts\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY = 50;\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetcher\n}) {\n  async function fetchJson(endpoint, options, params) {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    const url = urljoin(baseUrl, `/v2/c${endpoint}`, params);\n    const response = await fetcher(url.toString(), {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getInboxNotifications(options) {\n    const json = await fetchJson(\"/inbox-notifications\", void 0, {\n      limit: options?.limit,\n      since: options?.since?.toISOString()\n    });\n    return {\n      threads: json.threads.map((thread) => convertToThreadData(thread)),\n      inboxNotifications: json.inboxNotifications.map(\n        (notification) => convertToInboxNotificationData(notification)\n      ),\n      deletedThreads: json.deletedThreads.map(\n        (info) => convertToThreadDeleteInfo(info)\n      ),\n      deletedInboxNotifications: json.deletedInboxNotifications.map(\n        (info) => convertToInboxNotificationDeleteInfo(info)\n      ),\n      meta: {\n        requestedAt: new Date(json.meta.requestedAt)\n      }\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await fetchJson(\"/inbox-notifications/count\");\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds: \"all\" })\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nfunction nanoid(length = 7) {\n  const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,./;[]~!@#$%&*()_+=-\";\n  const len = alphabet.length;\n  return Array.from(\n    { length },\n    () => alphabet.charAt(Math.floor(Math.random() * len))\n  ).join(\"\");\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition));\n      }\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== previousIndex) {\n        delta.push(moveDelta(previousIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this._items[existingItemIndex]?._parentPos;\n      const after2 = this._items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this._items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? this._items[index + 1]?._parentPos : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index) {\n  return {\n    index,\n    type: \"delete\"\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index,\n    type: \"move\",\n    previousIndex,\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze = process.env.NODE_ENV === \"production\" ? (\n  /* istanbul ignore next */\n  (x) => x\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return this._cache ?? (this._cache = this._toImmutable());\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar CommentsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction createCommentsApi(roomId, getAuthValue, fetchClientApi) {\n  async function fetchCommentsApi(endpoint, params, options) {\n    const authValue = await getAuthValue();\n    return fetchClientApi(roomId, endpoint, authValue, options, params);\n  }\n  async function fetchJson(endpoint, options, params) {\n    const response = await fetchCommentsApi(endpoint, params, options);\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new CommentsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new CommentsApiError(response.statusText, response.status);\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  async function getThreads(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const response = await fetchCommentsApi(\n      \"/threads\",\n      {\n        since: options?.since?.toISOString(),\n        query\n      },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        threads: json.data.map((thread) => convertToThreadData(thread)),\n        inboxNotifications: json.inboxNotifications.map(\n          (notification) => convertToInboxNotificationData(notification)\n        ),\n        deletedThreads: json.deletedThreads.map(\n          (info) => convertToThreadDeleteInfo(info)\n        ),\n        deletedInboxNotifications: json.deletedInboxNotifications.map(\n          (info) => convertToInboxNotificationDeleteInfo(info)\n        ),\n        meta: {\n          requestedAt: new Date(json.meta.requestedAt)\n        }\n      };\n    } else if (response.status === 404) {\n      return {\n        threads: [],\n        inboxNotifications: [],\n        deletedThreads: [],\n        deletedInboxNotifications: [],\n        meta: {\n          requestedAt: /* @__PURE__ */ new Date()\n        }\n      };\n    } else {\n      throw new Error(\"There was an error while getting threads.\");\n    }\n  }\n  async function getThread({ threadId }) {\n    const response = await fetchCommentsApi(\n      `/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return;\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId,\n    threadId\n  }) {\n    const thread = await fetchJson(\"/threads\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        id: threadId,\n        comment: {\n          id: commentId,\n          body\n        },\n        metadata\n      })\n    });\n    return convertToThreadData(thread);\n  }\n  async function deleteThread({ threadId }) {\n    await fetchJson(`/threads/${encodeURIComponent(threadId)}`, {\n      method: \"DELETE\"\n    });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/metadata`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(metadata)\n      }\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          id: commentId,\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body\n  }) {\n    const comment = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          body\n        })\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment2({\n    threadId,\n    commentId\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function addReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ emoji })\n      }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction2({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await fetchJson(\n      `/threads/${encodeURIComponent(threadId)}/comments/${encodeURIComponent(\n        commentId\n      )}/reactions/${encodeURIComponent(emoji)}`,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  return {\n    getThreads,\n    getThread,\n    createThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment: deleteComment2,\n    addReaction: addReaction2,\n    removeReaction: removeReaction2\n  };\n}\nvar MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 = 50;\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces: process.env.NODE_ENV !== \"production\" ? /* @__PURE__ */ new Map() : void 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = config.unstable_batchedUpdates ?? doNotBatchUpdates;\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getAuthBearerHeaderFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (process.env.NODE_ENV !== \"production\") {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (process.env.NODE_ENV !== \"production\") {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = context.dynamicSessionInfo.current?.scopes;\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  async function fetchClientApi(roomId, endpoint, authValue, options2, params) {\n    const url = urljoin(\n      config.baseUrl,\n      `/v2/c/rooms/${encodeURIComponent(roomId)}${endpoint}`,\n      params\n    );\n    const fetcher = config.polyfills?.fetch || /* istanbul ignore next */\n    fetch;\n    return await fetcher(url, {\n      ...options2,\n      headers: {\n        ...options2?.headers,\n        Authorization: `Bearer ${getAuthBearerHeaderFromAuthValue(authValue)}`\n      }\n    });\n  }\n  async function streamFetch(authValue, roomId) {\n    return fetchClientApi(roomId, \"/storage\", authValue, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n  }\n  async function httpPostToRoom(endpoint, body) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(config.roomId, endpoint, managedSocket.authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n  }\n  async function createTextMention(userId, mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      \"/text-mentions\",\n      managedSocket.authValue,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          userId,\n          mentionId\n        })\n      }\n    );\n  }\n  async function deleteTextMention(mentionId) {\n    if (!managedSocket.authValue) {\n      throw new Error(\"Not authorized\");\n    }\n    return fetchClientApi(\n      config.roomId,\n      `/text-mentions/${mentionId}`,\n      managedSocket.authValue,\n      {\n        method: \"DELETE\"\n      }\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    const authValue = await delegates.authenticate();\n    return fetchClientApi(config.roomId, \"/text-metadata\", authValue, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        type,\n        rootKey\n      })\n    });\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = context.dynamicSessionInfo.current?.nonce;\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpPostToRoom(\"/send-message\", { nonce, messages }).then(\n          (resp) => {\n            if (!resp.ok && resp.status === 403) {\n              managedSocket.reconnect();\n            }\n          }\n        );\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = self.current?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (updates.presence ?? false) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (process.env.NODE_ENV !== \"production\") {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (options2?.addToHistory) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (process.env.NODE_ENV !== \"production\") {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = context.opStackTraces?.get(opId);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) {\n      return;\n    }\n    const result = await streamFetch(managedSocket.authValue, config.roomId);\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  const commentsApi = createCommentsApi(\n    config.roomId,\n    delegates.authenticate,\n    fetchClientApi\n  );\n  async function fetchNotificationsJson(endpoint, options2) {\n    const authValue = await delegates.authenticate();\n    const response = await fetchClientApi(\n      config.roomId,\n      endpoint,\n      authValue,\n      options2\n    );\n    if (!response.ok) {\n      if (response.status >= 400 && response.status < 600) {\n        let error3;\n        try {\n          const errorBody = await response.json();\n          error3 = new NotificationsApiError(\n            errorBody.message,\n            response.status,\n            errorBody\n          );\n        } catch {\n          error3 = new NotificationsApiError(\n            response.statusText,\n            response.status\n          );\n        }\n        throw error3;\n      }\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  function getRoomNotificationSettings() {\n    return fetchNotificationsJson(\n      \"/notification-settings\"\n    );\n  }\n  function updateRoomNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      \"/notification-settings\",\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\"/inbox-notifications/read\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({ inboxNotificationIds })\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        comments: {\n          ...commentsApi\n        },\n        notifications: {\n          getRoomNotificationSettings,\n          updateRoomNotificationSettings,\n          markInboxNotificationAsRead\n        }\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoize(waitUntilPresenceReady),\n      waitUntilStorageReady: memoize(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url = new URL(baseUrl);\n    url.protocol = url.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url.pathname = \"/v7\";\n    url.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url.toString());\n  };\n}\n\n// src/store.ts\nfunction createClientStore() {\n  const store = createStore({\n    threads: {},\n    queries: {},\n    optimisticUpdates: [],\n    inboxNotifications: {},\n    notificationSettings: {}\n  });\n  const optimisticUpdatesEventSource = makeEventSource();\n  return {\n    ...store,\n    deleteThread(threadId) {\n      store.set((state) => {\n        return {\n          ...state,\n          threads: deleteKeyImmutable(state.threads, threadId),\n          inboxNotifications: Object.fromEntries(\n            Object.entries(state.inboxNotifications).filter(\n              ([_id, notification]) => notification.kind === \"thread\" && notification.threadId === threadId\n            )\n          )\n        };\n      });\n    },\n    updateThreadAndNotification(thread, inboxNotification) {\n      store.set((state) => {\n        const existingThread = state.threads[thread.id];\n        return {\n          ...state,\n          threads: existingThread === void 0 || compareThreads(thread, existingThread) === 1 ? { ...state.threads, [thread.id]: thread } : state.threads,\n          inboxNotifications: inboxNotification === void 0 ? state.inboxNotifications : {\n            ...state.inboxNotifications,\n            [inboxNotification.id]: inboxNotification\n          }\n        };\n      });\n    },\n    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads, deletedInboxNotifications, queryKey) {\n      store.set((state) => ({\n        ...state,\n        threads: applyThreadUpdates(state.threads, {\n          newThreads: threads,\n          deletedThreads\n        }),\n        inboxNotifications: applyNotificationsUpdates(\n          state.inboxNotifications,\n          {\n            newInboxNotifications: inboxNotifications,\n            deletedNotifications: deletedInboxNotifications\n          }\n        ),\n        queries: queryKey !== void 0 ? {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        } : state.queries\n      }));\n    },\n    updateRoomInboxNotificationSettings(roomId, settings, queryKey) {\n      store.set((state) => ({\n        ...state,\n        notificationSettings: {\n          ...state.notificationSettings,\n          [roomId]: settings\n        },\n        queries: {\n          ...state.queries,\n          [queryKey]: {\n            isLoading: false\n          }\n        }\n      }));\n    },\n    pushOptimisticUpdate(optimisticUpdate) {\n      optimisticUpdatesEventSource.notify(optimisticUpdate);\n      store.set((state) => ({\n        ...state,\n        optimisticUpdates: [...state.optimisticUpdates, optimisticUpdate]\n      }));\n    },\n    setQueryState(queryKey, queryState) {\n      store.set((state) => ({\n        ...state,\n        queries: {\n          ...state.queries,\n          [queryKey]: queryState\n        }\n      }));\n    },\n    optimisticUpdatesEventSource\n  };\n}\nfunction deleteKeyImmutable(record, key) {\n  if (Object.prototype.hasOwnProperty.call(record, key)) {\n    const { [key]: _toDelete, ...rest } = record;\n    return rest;\n  }\n  return record;\n}\nfunction compareThreads(thread1, thread2) {\n  if (thread1.updatedAt && thread2.updatedAt) {\n    return thread1.updatedAt > thread2.updatedAt ? 1 : thread1.updatedAt < thread2.updatedAt ? -1 : 0;\n  } else if (thread1.updatedAt || thread2.updatedAt) {\n    return thread1.updatedAt ? 1 : -1;\n  }\n  if (thread1.createdAt > thread2.createdAt) {\n    return 1;\n  } else if (thread1.createdAt < thread2.createdAt) {\n    return -1;\n  }\n  return 0;\n}\nfunction applyOptimisticUpdates(state) {\n  const result = {\n    threads: {\n      ...state.threads\n    },\n    inboxNotifications: {\n      ...state.inboxNotifications\n    },\n    notificationSettings: {\n      ...state.notificationSettings\n    }\n  };\n  for (const optimisticUpdate of state.optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        result.threads[optimisticUpdate.thread.id] = optimisticUpdate.thread;\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        if (thread.deletedAt !== void 0) {\n          break;\n        }\n        if (thread.updatedAt !== void 0 && thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        result.threads[thread.id] = {\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        };\n        break;\n      }\n      case \"create-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        const inboxNotification = Object.values(result.inboxNotifications).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        result.inboxNotifications[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = result.threads[optimisticUpdate.comment.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = upsertComment(\n          thread,\n          optimisticUpdate.comment\n        );\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = deleteComment(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.deletedAt\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[optimisticUpdate.threadId] = {\n          ...result.threads[optimisticUpdate.threadId],\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        };\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = addReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.reaction\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = result.threads[optimisticUpdate.threadId];\n        if (thread === void 0) {\n          break;\n        }\n        result.threads[thread.id] = removeReaction(\n          thread,\n          optimisticUpdate.commentId,\n          optimisticUpdate.emoji,\n          optimisticUpdate.userId,\n          optimisticUpdate.removedAt\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        result.inboxNotifications[optimisticUpdate.inboxNotificationId] = {\n          ...state.inboxNotifications[optimisticUpdate.inboxNotificationId],\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-inbox-notifications-as-read\": {\n        for (const id in result.inboxNotifications) {\n          result.inboxNotifications[id] = {\n            ...result.inboxNotifications[id],\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"update-notification-settings\": {\n        result.notificationSettings[optimisticUpdate.roomId] = {\n          ...result.notificationSettings[optimisticUpdate.roomId],\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return result;\n}\nfunction applyThreadUpdates(existingThreads, updates) {\n  const updatedThreads = { ...existingThreads };\n  updates.newThreads.forEach((thread) => {\n    const existingThread = updatedThreads[thread.id];\n    if (existingThread) {\n      const result = compareThreads(existingThread, thread);\n      if (result === 1) return;\n    }\n    updatedThreads[thread.id] = thread;\n  });\n  updates.deletedThreads.forEach(({ id, deletedAt }) => {\n    const existingThread = updatedThreads[id];\n    if (existingThread === void 0) return;\n    existingThread.deletedAt = deletedAt;\n    existingThread.updatedAt = deletedAt;\n    existingThread.comments = [];\n  });\n  return updatedThreads;\n}\nfunction applyNotificationsUpdates(existingInboxNotifications, updates) {\n  const updatedInboxNotifications = { ...existingInboxNotifications };\n  updates.newInboxNotifications.forEach((notification) => {\n    const existingNotification = updatedInboxNotifications[notification.id];\n    if (existingNotification) {\n      const result = compareInboxNotifications(\n        existingNotification,\n        notification\n      );\n      if (result === 1) return;\n    }\n    updatedInboxNotifications[notification.id] = notification;\n  });\n  updates.deletedNotifications.forEach(\n    ({ id }) => delete updatedInboxNotifications[id]\n  );\n  return updatedInboxNotifications;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction upsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt?.getTime() || 0, comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt?.getTime() || 0,\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction deleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      body: void 0\n    } : comment\n  );\n  if (!updatedComments.some((comment) => comment.deletedAt === void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt,\n      comments: []\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction addReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction removeReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt?.getTime() || 0)\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction getAuthBearerHeaderFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: options2?.unstable_batchedUpdates,\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const {\n    getInboxNotifications,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead\n  } = createNotificationsApi({\n    baseUrl,\n    fetcher: clientOptions.polyfills?.fetch || /* istanbul ignore next */\n    fetch,\n    authManager,\n    currentUserIdStore\n  });\n  const cacheStore = createClientStore();\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const usersStore = createBatchStore(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const roomsInfoStore = createBatchStore(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  return Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Internal\n      [kInternal]: {\n        notifications: {\n          getInboxNotifications,\n          getUnreadInboxNotificationsCount,\n          markAllInboxNotificationsAsRead,\n          markInboxNotificationAsRead\n        },\n        currentUserIdStore,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        cacheStore,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n}\nvar NotificationsApiError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (process.env.NODE_ENV !== \"production\") {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {\n    return () => {\n    };\n  }\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyText(element) {\n  return \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url) {\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  } else if (url.startsWith(\"www.\")) {\n    return \"https://\" + url;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ?? element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nfunction makePoller(callback) {\n  let context = {\n    state: \"stopped\",\n    timeoutHandle: null,\n    interval: null,\n    lastScheduledAt: null,\n    remainingInterval: null\n  };\n  function poll() {\n    if (context.state === \"running\") {\n      schedule(context.interval);\n    }\n    void callback();\n  }\n  function schedule(interval) {\n    context = {\n      state: \"running\",\n      interval: context.state !== \"stopped\" ? context.interval : interval,\n      lastScheduledAt: performance.now(),\n      timeoutHandle: setTimeout(poll, interval),\n      remainingInterval: null\n    };\n  }\n  function scheduleRemaining(remaining) {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    context = {\n      state: \"running\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: setTimeout(poll, remaining),\n      remainingInterval: null\n    };\n  }\n  function start(interval) {\n    if (context.state === \"running\") {\n      return;\n    }\n    schedule(interval);\n  }\n  function restart(interval) {\n    stop();\n    start(interval);\n  }\n  function pause() {\n    if (context.state !== \"running\") {\n      return;\n    }\n    clearTimeout(context.timeoutHandle);\n    context = {\n      state: \"paused\",\n      interval: context.interval,\n      lastScheduledAt: context.lastScheduledAt,\n      timeoutHandle: null,\n      remainingInterval: context.interval - (performance.now() - context.lastScheduledAt)\n    };\n  }\n  function resume() {\n    if (context.state !== \"paused\") {\n      return;\n    }\n    scheduleRemaining(context.remainingInterval);\n  }\n  function stop() {\n    if (context.state === \"stopped\") {\n      return;\n    }\n    if (context.timeoutHandle) {\n      clearTimeout(context.timeoutHandle);\n    }\n    context = {\n      state: \"stopped\",\n      interval: null,\n      lastScheduledAt: null,\n      timeoutHandle: null,\n      remainingInterval: null\n    };\n  }\n  return {\n    start,\n    restart,\n    pause,\n    resume,\n    stop\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null || Object.prototype.toString.call(objA) !== \"[object Object]\" || Object.prototype.toString.call(objB) !== \"[object Object]\") {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  ClientMsgCode,\n  CommentsApiError,\n  CrdtType,\n  LiveList,\n  LiveMap,\n  LiveObject,\n  NotificationsApiError,\n  OpCode,\n  ServerMsgCode,\n  WebsocketCloseCodes,\n  ackOp,\n  addReaction,\n  applyOptimisticUpdates,\n  asPos,\n  assert,\n  assertNever,\n  b64decode,\n  cloneLson,\n  fancy_console_exports as console,\n  convertToCommentData,\n  convertToCommentUserReaction,\n  convertToInboxNotificationData,\n  convertToThreadData,\n  createClient,\n  deleteComment,\n  deprecate,\n  deprecateIf,\n  detectDupes,\n  errorIf,\n  freeze,\n  getMentionedIdsFromCommentBody,\n  isChildCrdt,\n  isJsonArray,\n  isJsonObject,\n  isJsonScalar,\n  isLiveNode,\n  isPlainObject,\n  isRootCrdt,\n  kInternal,\n  legacy_patchImmutableObject,\n  lsonToJson,\n  makeEventSource,\n  makePoller,\n  makePosition,\n  nn,\n  objectToQuery,\n  patchLiveObjectKey,\n  raise,\n  removeReaction,\n  shallow,\n  stringify,\n  stringifyCommentBody,\n  throwUsageError,\n  toPlainLson,\n  tryParseJson,\n  upsertComment,\n  withTimeout\n};\n//# sourceMappingURL=index.mjs.map","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","// src/index.ts\nimport { detectDupes } from \"@liveblocks/core\";\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/client\";\nvar PKG_VERSION = \"2.1.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/index.ts\nimport {\n  createClient,\n  getMentionedIdsFromCommentBody,\n  LiveList,\n  LiveMap,\n  LiveObject,\n  shallow,\n  stringifyCommentBody,\n  toPlainLson\n} from \"@liveblocks/core\";\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  LiveList,\n  LiveMap,\n  LiveObject,\n  createClient,\n  getMentionedIdsFromCommentBody,\n  shallow,\n  stringifyCommentBody,\n  toPlainLson\n};\n//# sourceMappingURL=index.mjs.map","// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"2.1.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/ClientSideSuspense.tsx\nimport * as React from \"react\";\nfunction ClientSideSuspense(props) {\n  const [mounted, setMounted] = React.useState(false);\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: props.fallback }, mounted ? typeof props.children === \"function\" ? props.children() : props.children : props.fallback);\n}\n\n// src/liveblocks.tsx\nimport { createClient, kInternal, makePoller, raise } from \"@liveblocks/core\";\nimport { nanoid } from \"nanoid\";\nimport React2, {\n  createContext,\n  useCallback as useCallback2,\n  useContext,\n  useEffect as useEffect3,\n  useMemo\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\n\n// src/comments/lib/selected-inbox-notifications.ts\nimport { applyOptimisticUpdates } from \"@liveblocks/core\";\nfunction selectedInboxNotifications(state) {\n  const result = applyOptimisticUpdates(state);\n  return Object.values(result.inboxNotifications).sort(\n    // Sort so that the most recent notifications are first\n    (a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()\n  );\n}\n\n// src/lib/retry-error.ts\nvar MAX_ERROR_RETRY_COUNT = 5;\nvar ERROR_RETRY_INTERVAL = 5e3;\nfunction retryError(action, retryCount) {\n  if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n  setTimeout(() => {\n    void action();\n  }, timeout);\n}\n\n// src/lib/use-initial.ts\nimport { useCallback, useReducer } from \"react\";\n\n// src/lib/use-latest.ts\nimport { useEffect as useEffect2, useRef } from \"react\";\nfunction useLatest(value) {\n  const ref = useRef(value);\n  useEffect2(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop = (state) => state;\nfunction useInitial(value) {\n  return useReducer(noop, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return useCallback((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/liveblocks.tsx\nvar ClientContext = createContext(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nvar POLLING_INTERVAL = 60 * 1e3;\nvar INBOX_NOTIFICATIONS_QUERY = \"INBOX_NOTIFICATIONS\";\nfunction selectorFor_useInboxNotifications(state) {\n  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n  if (query === void 0 || query.isLoading) {\n    return {\n      isLoading: true\n    };\n  }\n  if (query.error !== void 0) {\n    return {\n      error: query.error,\n      isLoading: false\n    };\n  }\n  return {\n    inboxNotifications: selectedInboxNotifications(state),\n    isLoading: false\n  };\n}\nfunction selectorFor_useInboxNotificationsSuspense(state) {\n  return {\n    inboxNotifications: selectedInboxNotifications(state),\n    isLoading: false\n  };\n}\nfunction selectUnreadInboxNotificationsCount(state) {\n  let count = 0;\n  for (const notification of selectedInboxNotifications(state)) {\n    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction selectorFor_useUnreadInboxNotificationsCount(state) {\n  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n  if (query === void 0 || query.isLoading) {\n    return {\n      isLoading: true\n    };\n  }\n  if (query.error !== void 0) {\n    return {\n      error: query.error,\n      isLoading: false\n    };\n  }\n  return {\n    isLoading: false,\n    count: selectUnreadInboxNotificationsCount(state)\n  };\n}\nfunction selectorFor_useUnreadInboxNotificationsCountSuspense(state) {\n  return {\n    isLoading: false,\n    count: selectUnreadInboxNotificationsCount(state)\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeExtrasForClient(client) {\n  const internals = client[kInternal];\n  const store = internals.cacheStore;\n  const notifications = internals.notifications;\n  let fetchInboxNotifications$ = null;\n  let lastRequestedAt;\n  const poller = makePoller(\n    () => notifications.getInboxNotifications({ since: lastRequestedAt }).then(\n      (result) => {\n        lastRequestedAt = result.meta.requestedAt;\n        store.updateThreadsAndNotifications(\n          result.threads,\n          result.inboxNotifications,\n          result.deletedThreads,\n          result.deletedInboxNotifications,\n          INBOX_NOTIFICATIONS_QUERY\n        );\n      },\n      () => {\n      }\n    )\n  );\n  async function fetchInboxNotifications({ retryCount } = { retryCount: 0 }) {\n    if (fetchInboxNotifications$ !== null) {\n      return fetchInboxNotifications$;\n    }\n    store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n      isLoading: true\n    });\n    try {\n      fetchInboxNotifications$ = notifications.getInboxNotifications();\n      const result = await fetchInboxNotifications$;\n      store.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications,\n        result.deletedThreads,\n        result.deletedInboxNotifications,\n        INBOX_NOTIFICATIONS_QUERY\n      );\n      if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n        lastRequestedAt = result.meta.requestedAt;\n      }\n      poller.start(POLLING_INTERVAL);\n    } catch (er) {\n      fetchInboxNotifications$ = null;\n      retryError(() => {\n        void fetchInboxNotifications({\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n        isLoading: false,\n        error: er\n      });\n    }\n    return;\n  }\n  let inboxNotificationsSubscribers = 0;\n  function useSubscribeToInboxNotificationsEffect(options) {\n    const autoFetch = useInitial(options?.autoFetch ?? true);\n    useEffect3(() => {\n      if (autoFetch) {\n        void fetchInboxNotifications();\n      }\n      inboxNotificationsSubscribers++;\n      poller.start(POLLING_INTERVAL);\n      return () => {\n        if (inboxNotificationsSubscribers <= 0) {\n          console.warn(\n            `Internal unexpected behavior. Cannot decrease subscriber count for query \"${INBOX_NOTIFICATIONS_QUERY}\"`\n          );\n          return;\n        }\n        inboxNotificationsSubscribers--;\n        if (inboxNotificationsSubscribers <= 0) {\n          poller.stop();\n        }\n      };\n    }, [autoFetch]);\n  }\n  return {\n    store,\n    notifications,\n    fetchInboxNotifications,\n    useSubscribeToInboxNotificationsEffect\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ React2.createElement(ClientContext.Provider, { value: client }, props.children);\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client) {\n  const { store, useSubscribeToInboxNotificationsEffect } = getExtrasForClient(client);\n  useSubscribeToInboxNotificationsEffect();\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    store.get,\n    store.get,\n    selectorFor_useInboxNotifications\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  const {\n    store,\n    fetchInboxNotifications,\n    useSubscribeToInboxNotificationsEffect\n  } = getExtrasForClient(client);\n  const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n  if (query === void 0 || query.isLoading) {\n    throw fetchInboxNotifications();\n  }\n  if (query.error !== void 0) {\n    throw query.error;\n  }\n  useSubscribeToInboxNotificationsEffect({ autoFetch: false });\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    store.get,\n    store.get,\n    selectorFor_useInboxNotificationsSuspense\n  );\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  const { store, useSubscribeToInboxNotificationsEffect } = getExtrasForClient(client);\n  useSubscribeToInboxNotificationsEffect();\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    store.get,\n    store.get,\n    selectorFor_useUnreadInboxNotificationsCount\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  const {\n    store,\n    fetchInboxNotifications,\n    useSubscribeToInboxNotificationsEffect\n  } = getExtrasForClient(client);\n  const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n  if (query === void 0 || query.isLoading) {\n    throw fetchInboxNotifications();\n  }\n  useSubscribeToInboxNotificationsEffect({ autoFetch: false });\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    store.get,\n    store.get,\n    selectorFor_useUnreadInboxNotificationsCountSuspense\n  );\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return useCallback2(\n    (inboxNotificationId) => {\n      const { store, notifications } = getExtrasForClient(client);\n      const optimisticUpdateId = nanoid();\n      const readAt = /* @__PURE__ */ new Date();\n      store.pushOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        id: optimisticUpdateId,\n        inboxNotificationId,\n        readAt\n      });\n      notifications.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.set((state) => {\n            const existingNotification = state.inboxNotifications[inboxNotificationId];\n            if (existingNotification === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                )\n              };\n            }\n            return {\n              ...state,\n              inboxNotifications: {\n                ...state.inboxNotifications,\n                [inboxNotificationId]: {\n                  ...existingNotification,\n                  readAt\n                }\n              },\n              optimisticUpdates: state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              )\n            };\n          });\n        },\n        () => {\n          store.set((state) => ({\n            ...state,\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return useCallback2(() => {\n    const { store, notifications } = getExtrasForClient(client);\n    const optimisticUpdateId = nanoid();\n    const readAt = /* @__PURE__ */ new Date();\n    store.pushOptimisticUpdate({\n      type: \"mark-inbox-notifications-as-read\",\n      id: optimisticUpdateId,\n      readAt\n    });\n    notifications.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.set((state) => ({\n          ...state,\n          inboxNotifications: Object.fromEntries(\n            Array.from(Object.entries(state.inboxNotifications)).map(\n              ([id, inboxNotification]) => [\n                id,\n                { ...inboxNotification, readAt }\n              ]\n            )\n          ),\n          optimisticUpdates: state.optimisticUpdates.filter(\n            (update) => update.id !== optimisticUpdateId\n          )\n        }));\n      },\n      () => {\n        store.set((state) => ({\n          ...state,\n          optimisticUpdates: state.optimisticUpdates.filter(\n            (update) => update.id !== optimisticUpdateId\n          )\n        }));\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getExtrasForClient(client);\n  const selector = useCallback2(\n    (state) => {\n      const inboxNotification = state.inboxNotifications[inboxNotificationId] ?? raise(`Inbox notification with ID \"${inboxNotificationId}\" not found`);\n      if (inboxNotification.kind !== \"thread\") {\n        raise(\n          `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n        );\n      }\n      const thread = state.threads[inboxNotification.threadId] ?? raise(\n        `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n      );\n      return thread;\n    },\n    [inboxNotificationId]\n  );\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[kInternal].usersStore;\n  const getUserState = useCallback2(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  useEffect3(() => {\n    void usersStore.get(userId);\n  }, [usersStore, userId]);\n  const state = useSyncExternalStore(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  return state ? {\n    isLoading: state.isLoading,\n    user: state.data,\n    // Return an error if `undefined` was returned by `resolveUsers` for this user ID\n    error: !state.isLoading && !state.data && !state.error ? missingUserError(userId) : state.error\n  } : { isLoading: true };\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[kInternal].usersStore;\n  const getUserState = useCallback2(\n    () => usersStore.getState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.get(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = useSyncExternalStore(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  return {\n    isLoading: false,\n    user: state?.data,\n    error: state?.error\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n  const getRoomInfoState = useCallback2(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  useEffect3(() => {\n    void roomsInfoStore.get(roomId);\n  }, [roomsInfoStore, roomId]);\n  const state = useSyncExternalStore(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  return state ? {\n    isLoading: state.isLoading,\n    info: state.data,\n    // Return an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n    error: !state.isLoading && !state.data && !state.error ? missingRoomInfoError(roomId) : state.error\n  } : { isLoading: true };\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n  const getRoomInfoState = useCallback2(\n    () => roomsInfoStore.getState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.get(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = useSyncExternalStore(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  return {\n    isLoading: false,\n    info: state?.data,\n    error: state?.error\n  };\n}\nfunction createSharedContext(client) {\n  return {\n    classic: {\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId)\n    },\n    suspense: {\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId)\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return useContext(ClientContext);\n}\nfunction useClient() {\n  console.log(\"xxxx\");\n  return useClientOrNull() ?? raise(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ React2.createElement(ClientContext.Provider, { value: props.client }, props.children);\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = useMemo(() => createClient(options), []);\n  return /* @__PURE__ */ React2.createElement(LiveblocksProviderWithClient, { client }, children);\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient());\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\n\n// src/comments/errors.ts\nvar CreateThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateThreadError\";\n  }\n};\nvar DeleteThreadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete thread failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteThreadError\";\n  }\n};\nvar EditThreadMetadataError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit thread metadata failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditThreadMetadataError\";\n  }\n};\nvar CreateCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Create comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"CreateCommentError\";\n  }\n};\nvar EditCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Edit comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"EditCommentError\";\n  }\n};\nvar DeleteCommentError = class extends Error {\n  constructor(cause, context) {\n    super(\"Delete comment failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"DeleteCommentError\";\n  }\n};\nvar AddReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Add reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"AddReactionError\";\n  }\n};\nvar RemoveReactionError = class extends Error {\n  constructor(cause, context) {\n    super(\"Remove reaction failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"RemoveReactionError\";\n  }\n};\nvar MarkInboxNotificationAsReadError = class extends Error {\n  constructor(cause, context) {\n    super(\"Mark inbox notification as read failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"MarkInboxNotificationAsReadError\";\n  }\n};\nvar UpdateNotificationSettingsError = class extends Error {\n  constructor(cause, context) {\n    super(\"Update notification settings failed.\");\n    this.cause = cause;\n    this.context = context;\n    this.name = \"UpdateNotificationSettingsError\";\n  }\n};\n\n// src/comments/lib/selected-threads.ts\nimport {\n  applyOptimisticUpdates as applyOptimisticUpdates2\n} from \"@liveblocks/core\";\nfunction selectedThreads(roomId, state, options) {\n  const result = applyOptimisticUpdates2(state);\n  const threads = Object.values(result.threads).filter(\n    (thread) => {\n      if (thread.roomId !== roomId) return false;\n      if (thread.deletedAt !== void 0) {\n        return false;\n      }\n      const query = options.query;\n      if (!query) return true;\n      for (const key in query.metadata) {\n        const metadataValue = thread.metadata[key];\n        const filterValue = query.metadata[key];\n        if (assertFilterIsStartsWithOperator(filterValue) && assertMetadataValueIsString(metadataValue)) {\n          if (metadataValue.startsWith(filterValue.startsWith)) {\n            return true;\n          }\n        }\n        if (metadataValue !== filterValue) {\n          return false;\n        }\n      }\n      return true;\n    }\n  );\n  return threads.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n}\nvar assertFilterIsStartsWithOperator = (filter) => {\n  if (typeof filter === \"object\" && typeof filter.startsWith === \"string\") {\n    return true;\n  } else {\n    return false;\n  }\n};\nvar assertMetadataValueIsString = (value) => {\n  return typeof value === \"string\";\n};\n\n// src/room.tsx\nimport { shallow } from \"@liveblocks/client\";\nimport {\n  addReaction,\n  CommentsApiError,\n  console as console2,\n  deleteComment,\n  deprecateIf,\n  errorIf,\n  kInternal as kInternal2,\n  makeEventSource,\n  makePoller as makePoller2,\n  NotificationsApiError,\n  removeReaction,\n  ServerMsgCode,\n  stringify,\n  upsertComment\n} from \"@liveblocks/core\";\nimport { nanoid as nanoid3 } from \"nanoid\";\nimport * as React4 from \"react\";\nimport { useSyncExternalStoreWithSelector as useSyncExternalStoreWithSelector2 } from \"use-sync-external-store/shim/with-selector.js\";\n\n// src/comments/lib/createIds.ts\nimport { nanoid as nanoid2 } from \"nanoid\";\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid2()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\n// src/comments/lib/select-notification-settings.ts\nimport {\n  applyOptimisticUpdates as applyOptimisticUpdates3,\n  nn\n} from \"@liveblocks/core\";\nfunction selectNotificationSettings(roomId, state) {\n  const { notificationSettings } = applyOptimisticUpdates3(state);\n  return nn(notificationSettings[roomId]);\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/use-scroll-to-comment-on-load-effect.ts\nimport * as React3 from \"react\";\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (state.isLoading) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  React3.useEffect(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\nvar noop2 = () => {\n};\nvar identity = (x) => x;\nvar missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\\u2019re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n  roomId\n)} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\nvar superfluous_unstable_batchedUpdates = \"You don\\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\\u2019re on React 18+ already.\";\nfunction useSyncExternalStore2(s, gs, gss) {\n  return useSyncExternalStoreWithSelector2(s, gs, gss, identity);\n}\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nvar POLLING_INTERVAL2 = 5 * 60 * 1e3;\nfunction makeNotificationSettingsQueryKey(roomId) {\n  return `${roomId}:NOTIFICATION_SETTINGS`;\n}\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(room) {\n  const self = room.getSelf();\n  if (self === null || self.id === void 0) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\nfunction handleApiError(err) {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join(\"\\n\");\n    console2.error(detailedMessage);\n  }\n  return new Error(message);\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getExtrasForClient2(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeExtrasForClient2(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeExtrasForClient2(client) {\n  const store = client[kInternal2].cacheStore;\n  const DEFAULT_DEDUPING_INTERVAL = 2e3;\n  const lastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  const requestsByQuery = /* @__PURE__ */ new Map();\n  const requestStatusByRoom = /* @__PURE__ */ new Map();\n  const subscribersByQuery = /* @__PURE__ */ new Map();\n  const poller = makePoller2(refreshThreadsAndNotifications);\n  async function refreshThreadsAndNotifications() {\n    const requests = [];\n    client[kInternal2].getRoomIds().map((roomId) => {\n      const room = client.getRoom(roomId);\n      if (room === null) return;\n      requests.push(getThreadsUpdates(room.id));\n    });\n    await Promise.allSettled(requests);\n  }\n  function incrementQuerySubscribers(queryKey) {\n    const subscribers = subscribersByQuery.get(queryKey) ?? 0;\n    subscribersByQuery.set(queryKey, subscribers + 1);\n    poller.start(POLLING_INTERVAL2);\n    return () => {\n      const subscribers2 = subscribersByQuery.get(queryKey);\n      if (subscribers2 === void 0 || subscribers2 <= 0) {\n        console2.warn(\n          `Internal unexpected behavior. Cannot decrease subscriber count for query \"${queryKey}\"`\n        );\n        return;\n      }\n      subscribersByQuery.set(queryKey, subscribers2 - 1);\n      let totalSubscribers = 0;\n      for (const subscribers3 of subscribersByQuery.values()) {\n        totalSubscribers += subscribers3;\n      }\n      if (totalSubscribers <= 0) {\n        poller.stop();\n      }\n    };\n  }\n  async function getThreadsUpdates(roomId) {\n    const room = client.getRoom(roomId);\n    if (room === null) return;\n    const since = lastRequestedAtByRoom.get(room.id);\n    if (since === void 0) return;\n    const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;\n    if (isFetchingThreadsUpdates === true) return;\n    try {\n      requestStatusByRoom.set(room.id, true);\n      const commentsAPI = room[kInternal2].comments;\n      const updates = await commentsAPI.getThreads({ since });\n      setTimeout(() => {\n        requestStatusByRoom.set(room.id, false);\n      }, DEFAULT_DEDUPING_INTERVAL);\n      store.updateThreadsAndNotifications(\n        updates.threads,\n        updates.inboxNotifications,\n        updates.deletedThreads,\n        updates.deletedInboxNotifications\n      );\n      lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);\n    } catch (err) {\n      requestStatusByRoom.set(room.id, false);\n      return;\n    }\n  }\n  async function getThreadsAndInboxNotifications(room, queryKey, options, { retryCount } = { retryCount: 0 }) {\n    const existingRequest = requestsByQuery.get(queryKey);\n    if (existingRequest !== void 0) return existingRequest;\n    const commentsAPI = room[kInternal2].comments;\n    const request = commentsAPI.getThreads(options);\n    requestsByQuery.set(queryKey, request);\n    store.setQueryState(queryKey, {\n      isLoading: true\n    });\n    try {\n      const result = await request;\n      store.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications,\n        result.deletedThreads,\n        result.deletedInboxNotifications,\n        queryKey\n      );\n      const lastRequestedAt = lastRequestedAtByRoom.get(room.id);\n      if (lastRequestedAt === void 0 || lastRequestedAt > result.meta.requestedAt) {\n        lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);\n      }\n      poller.start(POLLING_INTERVAL2);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n      retryError(() => {\n        void getThreadsAndInboxNotifications(room, queryKey, options, {\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQueryState(queryKey, {\n        isLoading: false,\n        error: err\n      });\n    }\n    return;\n  }\n  async function getInboxNotificationSettings(room, queryKey, { retryCount } = { retryCount: 0 }) {\n    const existingRequest = requestsByQuery.get(queryKey);\n    if (existingRequest !== void 0) return existingRequest;\n    try {\n      const request = room[kInternal2].notifications.getRoomNotificationSettings();\n      requestsByQuery.set(queryKey, request);\n      store.setQueryState(queryKey, {\n        isLoading: true\n      });\n      const settings = await request;\n      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n      retryError(() => {\n        void getInboxNotificationSettings(room, queryKey, {\n          retryCount: retryCount + 1\n        });\n      }, retryCount);\n      store.setQueryState(queryKey, {\n        isLoading: false,\n        error: err\n      });\n    }\n    return;\n  }\n  const commentsErrorEventSource = makeEventSource();\n  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {\n    store.set((state) => ({\n      ...state,\n      optimisticUpdates: state.optimisticUpdates.filter(\n        (update) => update.id !== optimisticUpdateId\n      )\n    }));\n    if (innerError instanceof CommentsApiError) {\n      const error = handleApiError(innerError);\n      commentsErrorEventSource.notify(createPublicError(error));\n      return;\n    }\n    if (innerError instanceof NotificationsApiError) {\n      handleApiError(innerError);\n      return;\n    }\n    throw innerError;\n  }\n  return {\n    store,\n    incrementQuerySubscribers,\n    commentsErrorEventSource,\n    getThreadsUpdates,\n    getThreadsAndInboxNotifications,\n    getInboxNotificationSettings,\n    onMutationFailure\n  };\n}\nvar RoomContext = React4.createContext(null);\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ React4.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ React4.createElement(RoomProvider, { ...props }));\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    },\n    useCommentsErrorListener\n  };\n  return Object.defineProperty(bundle, kInternal2, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = React4.useState(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = React4.useCallback(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ React4.createElement(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(React4.version) || 1;\n    const oldReactVersion = majorReactVersion < 18;\n    errorIf(\n      oldReactVersion && props.unstable_batchedUpdates === void 0,\n      missing_unstable_batchedUpdates(majorReactVersion, roomId)\n    );\n    deprecateIf(\n      !oldReactVersion && props.unstable_batchedUpdates !== void 0,\n      superfluous_unstable_batchedUpdates\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    unstable_batchedUpdates: props.unstable_batchedUpdates,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = React4.useState(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  React4.useEffect(() => {\n    const { store } = getExtrasForClient2(client);\n    async function handleCommentEvent(message) {\n      if (message.type === ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId);\n        return;\n      }\n      const info = await room[kInternal2].comments.getThread({\n        threadId: message.threadId\n      });\n      if (!info) {\n        store.deleteThread(message.threadId);\n        return;\n      }\n      const { thread, inboxNotification } = info;\n      const existingThread = store.get().threads[message.threadId];\n      switch (message.type) {\n        case ServerMsgCode.COMMENT_EDITED:\n        case ServerMsgCode.THREAD_METADATA_UPDATED:\n        case ServerMsgCode.COMMENT_REACTION_ADDED:\n        case ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        case ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadAndNotification(thread, inboxNotification);\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  React4.useEffect(() => {\n    const { getThreadsUpdates } = getExtrasForClient2(client);\n    void getThreadsUpdates(room.id);\n  }, [client, room.id]);\n  React4.useEffect(() => {\n    function handleIsOnline() {\n      const { getThreadsUpdates } = getExtrasForClient2(client);\n      void getThreadsUpdates(room.id);\n    }\n    window.addEventListener(\"online\", handleIsOnline);\n    return () => {\n      window.removeEventListener(\"online\", handleIsOnline);\n    };\n  }, [client, room.id]);\n  React4.useEffect(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ React4.createElement(RoomContext.Provider, { value: room }, props.children);\n}\nfunction useRoom() {\n  const room = useRoomOrNull();\n  if (room === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatus() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return React4.useCallback(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  React4.useEffect(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  React4.useEffect(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useErrorListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  React4.useEffect(\n    () => room.events.error.subscribe((e) => savedCallback.current(e)),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  React4.useEffect(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return useSyncExternalStore2(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return useSyncExternalStore2(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity;\n  const wrappedSelector = React4.useCallback(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector2(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector2(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = React4.useCallback(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = React4.useCallback(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = React4.useCallback(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = React4.useCallback(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = React4.useCallback(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = React4.useCallback(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,\n    [room, rootOrNull]\n  );\n  const getSnapshot = React4.useCallback(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector2(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return React4.useMemo(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = React4.useMemo(\n    () => generateQueryKey(room.id, options.query),\n    [room, options]\n  );\n  const { store, getThreadsAndInboxNotifications, incrementQuerySubscribers } = getExtrasForClient2(client);\n  React4.useEffect(() => {\n    void getThreadsAndInboxNotifications(room, queryKey, options);\n    return incrementQuerySubscribers(queryKey);\n  }, [room, queryKey]);\n  const selector = React4.useCallback(\n    (state2) => {\n      const query = state2.queries[queryKey];\n      if (query === void 0 || query.isLoading) {\n        return {\n          isLoading: true\n        };\n      }\n      return {\n        threads: selectedThreads(room.id, state2, options),\n        isLoading: false,\n        error: query.error\n      };\n    },\n    [room, queryKey]\n    // eslint-disable-line react-hooks/exhaustive-deps\n  );\n  const state = useSyncExternalStoreWithSelector2(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useCommentsErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  const { commentsErrorEventSource } = getExtrasForClient2(client);\n  React4.useEffect(() => {\n    return commentsErrorEventSource.subscribe(savedCallback.current);\n  }, [savedCallback, commentsErrorEventSource]);\n}\nfunction useCreateThread() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const threadId = createThreadId();\n      const commentId = createCommentId();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(room),\n        body,\n        reactions: []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId: room.id,\n        metadata,\n        comments: [newComment]\n      };\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"create-thread\",\n        thread: newThread,\n        id: optimisticUpdateId,\n        roomId: room.id\n      });\n      const commentsAPI = room[kInternal2].comments;\n      commentsAPI.createThread({ threadId, commentId, body, metadata }).then(\n        (thread) => {\n          store.set((state) => ({\n            ...state,\n            threads: {\n              ...state.threads,\n              [threadId]: thread\n            },\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateThreadError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body,\n            metadata\n          })\n        )\n      );\n      return newThread;\n    },\n    [client, room]\n  );\n}\nfunction useDeleteThread() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    (threadId) => {\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      const thread = store.get().threads[threadId];\n      const userId = getCurrentUserId(room);\n      if (thread?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      store.pushOptimisticUpdate({\n        type: \"delete-thread\",\n        id: optimisticUpdateId,\n        roomId: room.id,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      const commentsAPI = room[kInternal2].comments;\n      commentsAPI.deleteThread({ threadId }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            if (existingThread === void 0) {\n              return state;\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: {\n                  ...existingThread,\n                  updatedAt: /* @__PURE__ */ new Date(),\n                  deletedAt: /* @__PURE__ */ new Date()\n                }\n              },\n              optimisticUpdates: state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              )\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useEditThreadMetadata() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"edit-thread-metadata\",\n        metadata,\n        id: optimisticUpdateId,\n        threadId,\n        updatedAt\n      });\n      const commentsAPI = room[kInternal2].comments;\n      commentsAPI.editThreadMetadata({ metadata, threadId }).then(\n        (metadata2) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.deletedAt !== void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: {\n                  ...existingThread,\n                  metadata: metadata2\n                }\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditThreadMetadataError(error, {\n            roomId: room.id,\n            threadId,\n            metadata\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useCreateComment() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    ({ threadId, body }) => {\n      const commentId = createCommentId();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId: room.id,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(room),\n        body,\n        reactions: []\n      };\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"create-comment\",\n        comment,\n        id: optimisticUpdateId\n      });\n      room[kInternal2].comments.createComment({ threadId, commentId, body }).then(\n        (newComment) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            const inboxNotification = Object.values(\n              state.inboxNotifications\n            ).find(\n              (notification) => notification.kind === \"thread\" && notification.threadId === threadId\n            );\n            const updatedInboxNotifications = inboxNotification !== void 0 ? {\n              ...state.inboxNotifications,\n              [inboxNotification.id]: {\n                ...inboxNotification,\n                notifiedAt: newComment.createdAt,\n                readAt: newComment.createdAt\n              }\n            } : state.inboxNotifications;\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: upsertComment(existingThread, newComment)\n                // Upsert the new comment into the thread comments list (if applicable)\n              },\n              inboxNotifications: updatedInboxNotifications,\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (err2) => new CreateCommentError(err2, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n      return comment;\n    },\n    [client, room]\n  );\n}\nfunction useEditComment() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    ({ threadId, commentId, body }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      const thread = store.get().threads[threadId];\n      if (thread === void 0) {\n        console2.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = thread.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        console2.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      store.pushOptimisticUpdate({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body\n        },\n        id: optimisticUpdateId\n      });\n      room[kInternal2].comments.editComment({ threadId, commentId, body }).then(\n        (editedComment) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: upsertComment(existingThread, editedComment)\n                // Upsert the edited comment into the thread comments list (if applicable)\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new EditCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            body\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useDeleteComment() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        id: optimisticUpdateId,\n        roomId: room.id\n      });\n      room[kInternal2].comments.deleteComment({ threadId, commentId }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: deleteComment(existingThread, commentId, deletedAt)\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new DeleteCommentError(error, {\n            roomId: room.id,\n            threadId,\n            commentId\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useAddReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(room);\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        },\n        id: optimisticUpdateId\n      });\n      room[kInternal2].comments.addReaction({ threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: addReaction(\n                  existingThread,\n                  commentId,\n                  addedReaction\n                )\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new AddReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useRemoveReaction() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(room);\n      const removedAt = /* @__PURE__ */ new Date();\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt,\n        id: optimisticUpdateId\n      });\n      room[kInternal2].comments.removeReaction({ threadId, commentId, emoji }).then(\n        () => {\n          store.set((state) => {\n            const existingThread = state.threads[threadId];\n            const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            );\n            if (existingThread === void 0) {\n              return {\n                ...state,\n                optimisticUpdates: updatedOptimisticUpdates\n              };\n            }\n            return {\n              ...state,\n              threads: {\n                ...state.threads,\n                [threadId]: removeReaction(\n                  existingThread,\n                  commentId,\n                  emoji,\n                  userId,\n                  removedAt\n                )\n              },\n              optimisticUpdates: updatedOptimisticUpdates\n            };\n          });\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new RemoveReactionError(error, {\n            roomId: room.id,\n            threadId,\n            commentId,\n            emoji\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useMarkThreadAsRead() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    (threadId) => {\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      const inboxNotification = Object.values(\n        store.get().inboxNotifications\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const optimisticUpdateId = nanoid3();\n      const now = /* @__PURE__ */ new Date();\n      store.pushOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        id: optimisticUpdateId,\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      room[kInternal2].notifications.markInboxNotificationAsRead(inboxNotification.id).then(\n        () => {\n          store.set((state) => ({\n            ...state,\n            inboxNotifications: {\n              ...state.inboxNotifications,\n              [inboxNotification.id]: {\n                ...inboxNotification,\n                readAt: now\n              }\n            },\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        },\n        (err) => {\n          onMutationFailure(\n            err,\n            optimisticUpdateId,\n            (error) => new MarkInboxNotificationAsReadError(error, {\n              inboxNotificationId: inboxNotification.id\n            })\n          );\n          return;\n        }\n      );\n    },\n    [client, room]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getExtrasForClient2(client);\n  const selector = React4.useCallback(\n    (state) => {\n      const inboxNotification = selectedInboxNotifications(state).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      const thread = state.threads[threadId];\n      if (inboxNotification === void 0 || thread === void 0) {\n        return {\n          status: \"not-subscribed\"\n        };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: inboxNotification.readAt\n      };\n    },\n    [threadId]\n  );\n  return useSyncExternalStoreWithSelector2(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n}\nfunction useRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getExtrasForClient2(client);\n  React4.useEffect(() => {\n    const { getInboxNotificationSettings } = getExtrasForClient2(client);\n    const queryKey = makeNotificationSettingsQueryKey(room.id);\n    void getInboxNotificationSettings(room, queryKey);\n  }, [client, room]);\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const selector = React4.useCallback(\n    (state) => {\n      const query = state.queries[makeNotificationSettingsQueryKey(room.id)];\n      if (query === void 0 || query.isLoading) {\n        return { isLoading: true };\n      }\n      if (query.error !== void 0) {\n        return { isLoading: false, error: query.error };\n      }\n      return {\n        isLoading: false,\n        settings: selectNotificationSettings(room.id, state)\n      };\n    },\n    [room]\n  );\n  const settings = useSyncExternalStoreWithSelector2(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  return React4.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return React4.useCallback(\n    (settings) => {\n      const optimisticUpdateId = nanoid3();\n      const { store, onMutationFailure } = getExtrasForClient2(client);\n      store.pushOptimisticUpdate({\n        id: optimisticUpdateId,\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room[kInternal2].notifications.updateRoomNotificationSettings(settings).then(\n        (settings2) => {\n          store.set((state) => ({\n            ...state,\n            notificationSettings: {\n              [room.id]: settings2\n            },\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            )\n          }));\n        },\n        (err) => onMutationFailure(\n          err,\n          optimisticUpdateId,\n          (error) => new UpdateNotificationSettingsError(error, {\n            roomId: room.id\n          })\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n    );\n  }\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense() {\n  useSuspendUntilStorageReady();\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useThreadsSuspense(options = {\n  query: { metadata: {} }\n}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = React4.useMemo(\n    () => generateQueryKey(room.id, options.query),\n    [room, options]\n  );\n  const { store, getThreadsAndInboxNotifications } = getExtrasForClient2(client);\n  const query = store.get().queries[queryKey];\n  if (query === void 0 || query.isLoading) {\n    throw getThreadsAndInboxNotifications(room, queryKey, options);\n  }\n  if (query.error) {\n    throw query.error;\n  }\n  const selector = React4.useCallback(\n    (state2) => {\n      return {\n        threads: selectedThreads(room.id, state2, options),\n        isLoading: false\n      };\n    },\n    [room, queryKey]\n    // eslint-disable-line react-hooks/exhaustive-deps\n  );\n  React4.useEffect(() => {\n    const { incrementQuerySubscribers } = getExtrasForClient2(client);\n    return incrementQuerySubscribers(queryKey);\n  }, [client, queryKey]);\n  const state = useSyncExternalStoreWithSelector2(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, state);\n  return state;\n}\nfunction useRoomNotificationSettingsSuspense() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const queryKey = makeNotificationSettingsQueryKey(room.id);\n  const { store, getInboxNotificationSettings } = getExtrasForClient2(client);\n  const query = store.get().queries[queryKey];\n  if (query === void 0 || query.isLoading) {\n    throw getInboxNotificationSettings(room, queryKey);\n  }\n  if (query.error) {\n    throw query.error;\n  }\n  const selector = React4.useCallback(\n    (state) => {\n      return {\n        isLoading: false,\n        settings: selectNotificationSettings(room.id, state)\n      };\n    },\n    [room]\n  );\n  const settings = useSyncExternalStoreWithSelector2(\n    store.subscribe,\n    store.get,\n    store.get,\n    selector\n  );\n  return React4.useMemo(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomOrNull() {\n  return React4.useContext(RoomContext);\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nfunction generateQueryKey(roomId, options) {\n  return `${roomId}-${stringify(options ?? {})}`;\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\nexport {\n  PKG_NAME,\n  PKG_VERSION,\n  PKG_FORMAT,\n  ClientSideSuspense,\n  ClientContext,\n  useClient,\n  LiveblocksProvider,\n  createLiveblocksContext,\n  useInboxNotifications,\n  useInboxNotificationsSuspense,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useUnreadInboxNotificationsCount,\n  useUnreadInboxNotificationsCountSuspense,\n  useRoomInfo,\n  useRoomInfoSuspense,\n  _useInboxNotificationThread,\n  _useUser,\n  _useUserSuspense,\n  CreateThreadError,\n  selectedThreads,\n  RoomContext,\n  useStatus,\n  useStorageStatus,\n  useBatch,\n  useLostConnectionListener,\n  useErrorListener,\n  useHistory,\n  useUndo,\n  useRedo,\n  useCanUndo,\n  useCanRedo,\n  useOthersConnectionIds,\n  useCommentsErrorListener,\n  useCreateComment,\n  useEditComment,\n  useDeleteComment,\n  useRemoveReaction,\n  useMarkThreadAsRead,\n  useThreadSubscription,\n  useRoomNotificationSettings,\n  useUpdateRoomNotificationSettings,\n  useOthersConnectionIdsSuspense,\n  useStorageStatusSuspense,\n  createRoomContext,\n  _RoomProvider,\n  _useBroadcastEvent,\n  _useOthersListener,\n  _useRoom,\n  _useAddReaction,\n  _useMutation,\n  _useCreateThread,\n  _useDeleteThread,\n  _useEditThreadMetadata,\n  _useEventListener,\n  _useMyPresence,\n  _useOthersMapped,\n  _useOthersMappedSuspense,\n  _useThreads,\n  _useThreadsSuspense,\n  _useOther,\n  _useOthers,\n  _useOtherSuspense,\n  _useOthersSuspense,\n  _useStorage,\n  _useStorageSuspense,\n  _useSelf,\n  _useSelfSuspense,\n  _useStorageRoot,\n  _useUpdateMyPresence\n};\n//# sourceMappingURL=chunk-D4UC2JLP.mjs.map","import {\n  ClientContext,\n  ClientSideSuspense,\n  LiveblocksProvider,\n  PKG_FORMAT,\n  PKG_NAME,\n  PKG_VERSION,\n  RoomContext,\n  _RoomProvider,\n  _useAddReaction,\n  _useBroadcastEvent,\n  _useCreateThread,\n  _useDeleteThread,\n  _useEditThreadMetadata,\n  _useEventListener,\n  _useInboxNotificationThread,\n  _useMutation,\n  _useMyPresence,\n  _useOtherSuspense,\n  _useOthersListener,\n  _useOthersMappedSuspense,\n  _useOthersSuspense,\n  _useRoom,\n  _useSelfSuspense,\n  _useStorageRoot,\n  _useStorageSuspense,\n  _useThreadsSuspense,\n  _useUpdateMyPresence,\n  _useUserSuspense,\n  useBatch,\n  useCanRedo,\n  useCanUndo,\n  useClient,\n  useCreateComment,\n  useDeleteComment,\n  useEditComment,\n  useErrorListener,\n  useHistory,\n  useInboxNotificationsSuspense,\n  useLostConnectionListener,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useMarkThreadAsRead,\n  useOthersConnectionIdsSuspense,\n  useRedo,\n  useRemoveReaction,\n  useRoomInfoSuspense,\n  useRoomNotificationSettings,\n  useStatus,\n  useStorageStatusSuspense,\n  useThreadSubscription,\n  useUndo,\n  useUnreadInboxNotificationsCountSuspense,\n  useUpdateRoomNotificationSettings\n} from \"./chunk-D4UC2JLP.mjs\";\n\n// src/suspense.ts\nimport { detectDupes } from \"@liveblocks/core\";\nimport { shallow } from \"@liveblocks/client\";\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  ClientContext,\n  ClientSideSuspense,\n  LiveblocksProvider,\n  RoomContext,\n  _RoomProvider as RoomProvider,\n  shallow,\n  _useAddReaction as useAddReaction,\n  useBatch,\n  _useBroadcastEvent as useBroadcastEvent,\n  useCanRedo,\n  useCanUndo,\n  useClient,\n  useCreateComment,\n  _useCreateThread as useCreateThread,\n  useDeleteComment,\n  _useDeleteThread as useDeleteThread,\n  useEditComment,\n  _useEditThreadMetadata as useEditThreadMetadata,\n  useErrorListener,\n  _useEventListener as useEventListener,\n  useHistory,\n  _useInboxNotificationThread as useInboxNotificationThread,\n  useInboxNotificationsSuspense as useInboxNotifications,\n  useLostConnectionListener,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useMarkThreadAsRead,\n  _useMutation as useMutation,\n  _useMyPresence as useMyPresence,\n  _useOtherSuspense as useOther,\n  _useOthersSuspense as useOthers,\n  useOthersConnectionIdsSuspense as useOthersConnectionIds,\n  _useOthersListener as useOthersListener,\n  _useOthersMappedSuspense as useOthersMapped,\n  useRedo,\n  useRemoveReaction,\n  _useRoom as useRoom,\n  useRoomInfoSuspense as useRoomInfo,\n  useRoomNotificationSettings,\n  _useSelfSuspense as useSelf,\n  useStatus,\n  _useStorageSuspense as useStorage,\n  _useStorageRoot as useStorageRoot,\n  useStorageStatusSuspense as useStorageStatus,\n  useThreadSubscription,\n  _useThreadsSuspense as useThreads,\n  useUndo,\n  useUnreadInboxNotificationsCountSuspense as useUnreadInboxNotificationsCount,\n  _useUpdateMyPresence as useUpdateMyPresence,\n  useUpdateRoomNotificationSettings,\n  _useUserSuspense as useUser\n};\n//# sourceMappingURL=suspense.mjs.map","import {\n  ClientContext,\n  ClientSideSuspense,\n  CreateThreadError,\n  LiveblocksProvider,\n  PKG_FORMAT,\n  PKG_NAME,\n  PKG_VERSION,\n  RoomContext,\n  _RoomProvider,\n  _useAddReaction,\n  _useBroadcastEvent,\n  _useCreateThread,\n  _useDeleteThread,\n  _useEditThreadMetadata,\n  _useEventListener,\n  _useInboxNotificationThread,\n  _useMutation,\n  _useMyPresence,\n  _useOther,\n  _useOthers,\n  _useOthersListener,\n  _useOthersMapped,\n  _useRoom,\n  _useSelf,\n  _useStorage,\n  _useStorageRoot,\n  _useThreads,\n  _useUpdateMyPresence,\n  _useUser,\n  createLiveblocksContext,\n  createRoomContext,\n  selectedThreads,\n  useBatch,\n  useCanRedo,\n  useCanUndo,\n  useClient,\n  useCommentsErrorListener,\n  useCreateComment,\n  useDeleteComment,\n  useEditComment,\n  useErrorListener,\n  useHistory,\n  useInboxNotifications,\n  useLostConnectionListener,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useMarkThreadAsRead,\n  useOthersConnectionIds,\n  useRedo,\n  useRemoveReaction,\n  useRoomInfo,\n  useRoomNotificationSettings,\n  useStatus,\n  useStorageStatus,\n  useThreadSubscription,\n  useUndo,\n  useUnreadInboxNotificationsCount,\n  useUpdateRoomNotificationSettings\n} from \"./chunk-D4UC2JLP.mjs\";\n\n// src/index.ts\nimport { detectDupes } from \"@liveblocks/core\";\nimport { shallow } from \"@liveblocks/client\";\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nexport {\n  ClientContext,\n  ClientSideSuspense,\n  CreateThreadError,\n  LiveblocksProvider,\n  RoomContext,\n  _RoomProvider as RoomProvider,\n  createLiveblocksContext,\n  createRoomContext,\n  selectedThreads,\n  shallow,\n  _useAddReaction as useAddReaction,\n  useBatch,\n  _useBroadcastEvent as useBroadcastEvent,\n  useCanRedo,\n  useCanUndo,\n  useClient,\n  useCommentsErrorListener,\n  useCreateComment,\n  _useCreateThread as useCreateThread,\n  useDeleteComment,\n  _useDeleteThread as useDeleteThread,\n  useEditComment,\n  _useEditThreadMetadata as useEditThreadMetadata,\n  useErrorListener,\n  _useEventListener as useEventListener,\n  useHistory,\n  _useInboxNotificationThread as useInboxNotificationThread,\n  useInboxNotifications,\n  useLostConnectionListener,\n  useMarkAllInboxNotificationsAsRead,\n  useMarkInboxNotificationAsRead,\n  useMarkThreadAsRead,\n  _useMutation as useMutation,\n  _useMyPresence as useMyPresence,\n  _useOther as useOther,\n  _useOthers as useOthers,\n  useOthersConnectionIds,\n  _useOthersListener as useOthersListener,\n  _useOthersMapped as useOthersMapped,\n  useRedo,\n  useRemoveReaction,\n  _useRoom as useRoom,\n  useRoomInfo,\n  useRoomNotificationSettings,\n  _useSelf as useSelf,\n  useStatus,\n  _useStorage as useStorage,\n  _useStorageRoot as useStorageRoot,\n  useStorageStatus,\n  useThreadSubscription,\n  _useThreads as useThreads,\n  useUndo,\n  useUnreadInboxNotificationsCount,\n  _useUpdateMyPresence as useUpdateMyPresence,\n  useUpdateRoomNotificationSettings,\n  _useUser as useUser\n};\n//# sourceMappingURL=index.mjs.map","import React from \"react\";\nimport styles from \"./Loading.module.css\";\n\nexport function Loading() {\n  return (\n    <div className={styles.loading}>\n      <img src=\"https://liveblocks.io/loading.svg\" alt=\"Loading\" />\n    </div>\n  );\n}\n","import { ClientSideSuspense, RoomProvider } from \"@liveblocks/react\";\nimport { LiveList, LiveMap, LiveObject } from \"@liveblocks/client\";\nimport { type ReactNode } from \"react\";\nimport { Loading } from \"./Loading\";\nimport { type Layer, } from \"../whiteboard/liveblocks-example/types\";\n\nexport default function ({ children, roomID }: { children: ReactNode, roomID: string }) {\n    return (\n        <RoomProvider\n            id={roomID}\n            initialPresence={{\n                selection: [],\n                cursor: null,\n                pencilDraft: null,\n                penColor: null,\n            }}\n            initialStorage={{\n                layers: new LiveMap<string, LiveObject<Layer>>(),\n                layerIds: new LiveList([]),\n            }}\n        >\n            <ClientSideSuspense fallback={<Loading />}>{children}</ClientSideSuspense>\n        </RoomProvider>\n    );\n}"],"names":["__defProp","__export","target","all","name","PKG_NAME","PKG_VERSION","PKG_FORMAT","g","dupesDocs","SPACE","error","msg","detectDupes","pkgName","pkgVersion","pkgFormat","pkgId","pkgBuildInfo","assertNever","_value","errmsg","nn","value","controlledPromise","resolve","reject","res","rej","Promise_withResolvers","promise","makeEventSource","_onetimeObservers","_observers","_buffer","pause","unpause","event","notify","subscribe","callback","subscribeOnce","waitUntil","predicate","unsub","notifyOrBuffer","clear","count","fancy_console_exports","error2","errorWithTitle","warn","warnWithTitle","badge","bold","wrap","method","message","args","wrapWithTitle","title","distance","state1","state2","chunks1","chunks2","minLen","shared","up","down","patterns","targetState","levels","parts","result","i","slice","SafeContext","initialContext","self","allowed","patchableContext","patch","pair","key","nextId","FSM","state","nameOrPattern","enterFn","promiseFn","onOK","onError","abortController","signal","done","data","reason","matches","prefix","mapping","srcState","map","type","target_","targetFn","stateOrPattern","after2","ms","timeoutID","eventName","_a","enterPatterns","pattern","cleanupFn","oldState","nextTarget","nextState","effects","effectsToRun","effect","raise","isPlainObject","blob","entries","obj","tryParseJson","rawMessage","deepClone","b64decode","b64value","formattedValue","c","compact","items","item","compactObject","newObj","k","withTimeout","millis","timerID","timer$","_","memoize","factoryFn","cached","ServerMsgCode","ServerMsgCode2","shouldDisconnect","code","shouldReauth","shouldRetryWithoutReauth","isIdle","status","toNewConnectionStatus","machine","BACKOFF_DELAYS","RESET_DELAY","BACKOFF_DELAYS_SLOW","HEARTBEAT_INTERVAL","PONG_TIMEOUT","AUTH_TIMEOUT","SOCKET_CONNECT_TIMEOUT","StopRetrying","LiveblocksError","nextBackoffDelay","currentDelay","delays","delay","increaseBackoffDelay","context","increaseBackoffDelayAggressively","resetSuccessCount","log","level","logger","logPrematureErrorOrCloseEvent","e","conn","ctx","isCloseEvent","logCloseEvent","details","logPermanentClose","error3","enableTracing","start","log2","unsubs","from","to","defineConnectivityEvents","statusDidChange","didConnect","didDisconnect","lastStatus","unsubscribe","currStatus","assign","createConnectionStateMachine","delegates","options","onMessage","onLiveblocksError","fireErrorEvent","errcode","err","okEvent","failedEvent","onSocketError","onSocketClose","onSocketMessage","teardownSocket","socket","capturedPrematureEvent","unconfirmedSocket","connect$","actor$","didReceiveActor","waitForActorId","serverMsg","failure","sendHeartbeat","maybeHeartbeat","doc","ctx2","win","root","onNetworkOffline","onNetworkBackOnline","onVisibilityChange","cleanups","ManagedSocket","enableDebugLogging","events","cleanup","canWriteStorage","scopes","canComment","isValidAuthTokenPayload","parseAuthToken","rawTokenString","tokenParts","payload","createAuthManager","authOptions","authentication","prepareAuthentication","seenTokens","tokens","expiryTimes","requestPromises","reset","hasCorrespondingScopes","requestedScope","getCachedToken","requestOptions","now","token","resource","makeAuthRequest","fetcher","response","fetchAuthEndpoint","parsed","getAuthValue","cachedToken","currentPromise","expiresAt","publicApiKey","authEndpoint","fetch2","endpoint","body","er","DEFAULT_BASE_URL","kInternal","eventSource","stringify","object","sortedObject","sortedObject2","DEFAULT_SIZE","DEFAULT_DELAY","noop","BatchCall","Batch","calls","call","results","index","existingCall","call2","createBatchStore","batch","cache","eventSource2","getCacheKey","setStateAndNotify","cacheKey","get","getState","createStore","initialState","subscribers","set","newState","subscriber","convertToCommentData","editedAt","createdAt","reactions","reaction","deletedAt","convertToThreadData","updatedAt","comments","comment","convertToCommentUserReaction","convertToInboxNotificationData","notifiedAt","readAt","activities","activity","convertToThreadDeleteInfo","convertToInboxNotificationDeleteInfo","toURLSearchParams","params","urljoin","baseUrl","path","url","MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY","createNotificationsApi","authManager","currentUserIdStore","fetchJson","authValue","userId","getAuthBearerHeaderFromAuthValue","errorBody","NotificationsApiError","getInboxNotifications","json","thread","notification","info","getUnreadInboxNotificationsCount","markAllInboxNotificationsAsRead","markInboxNotificationsAsRead","inboxNotificationIds","batchedMarkInboxNotificationsAsRead","batchedInboxNotificationIds","markInboxNotificationAsRead","inboxNotificationId","MIN_CODE","MAX_CODE","NUM_DIGITS","ZERO","nthDigit","ONE","ZERO_NINE","n","makePosition","x","y","between","after","before","pos","lastIndex","lo","hi","_between","loLen","hiLen","loCode","hiCode","size","suffix","takeN","MIN_NON_ZERO_CODE","isPos","str","lastIdx","last","convertToPos","codes","asPos","isAckOp","op","HasParent","node","NoParent","Orphaned","oldKey","oldPos","AbstractCrdt","_isLocal","newParentNode","newParentKey","id","pool","isRootCrdt","crdt","isChildCrdt","nanoid","length","alphabet","len","LiveRegister","_LiveRegister","_parentToChildren","register","parentId","parentKey","_op","_crdt","isLocal","compareNodePosition","itemA","itemB","posA","posB","LiveList","_LiveList","position","newPosition","lsonToLiveNode","parentToChildren","list","children","id2","child","deserialize","ops","parentKey2","childOps","HACK_addIntentAndDeletedIdToOperation","childOpId","creationOpToLiveNode","deletedId","indexOfItemWithSamePosition","itemWithSamePosition","makeUpdate","setDelta","delta","deleteDelta2","updates","insertDelta","deletedDelta","unacknowledgedOpId","existingItem","deleteDelta","previousIndex","newIndex","moveDelta","orphan","recreatedItemIndex","newItem","deletedItem","existingItemIndex","itemIndexAtPosition","oldPositionIndex","newKey","before2","_b","_c","indexOfItemWithSameKey","reverse","source","indexToDelete","previousKey","element","targetIndex","beforePosition","afterPosition","previousPosition","storageUpdates","childRecordId","reverseOps","updateDelta","childId","existingId","entry","liveNodeToLson","callbackfn","searchElement","fromIndex","LiveListIterator","shiftedPosition","liveList","deltaUpdates","freeze","LiveMap","_LiveMap","entries2","mappedEntries","_item","_key","isLiveNode","opId","lastUpdateOpId","previousValue","thisId","oldValue","innerIterator","iteratorValue","key2","val","LiveObject","_LiveObject","tuple","o","liveObj","deserializeToLson","isLiveStructure","creationOpToLson","isModified","reverseUpdate","keyAsString","newValue","updatedProps","reverseUpdateOp","newAttachChildOps","createCrdtOp","nodeId","isSameNodeOrChildOf","parent","isLiveList","isLiveMap","isLiveObject","isLiveRegister","cloneLson","getTreesDiffOperations","currentItems","newItems","currentCrdt","mergeObjectStorageUpdates","first","second","mergeMapStorageUpdates","mergeListStorageUpdates","mergeStorageUpdates","isJsonScalar","isJsonArray","isJsonObject","identifierRegex","objectToQuery","filterList","keyValuePairs","keyValuePairsWithOperator","indexedKeys","isSimpleValue","isValueWithOperator","getFiltersFromKeyValuePairs","getFiltersFromKeyValuePairsWithOperator","nestedEntries","nKeyValuePairs","nKeyValuePairsWithOperator","nestedKey","nestedValue","isStringEmpty","formatFilterKey","operator","formatFilter","formatFilterValue","filters","ClientMsgCode","ClientMsgCode2","merge","updated","ImmutableRef","makeUser","presence","connectionId","canWrite","OthersRef","cachedUser","computedUser","metaUserId","metaUserInfo","oldPresence","newPresence","PatchableRef","oldData","newData","ValueRef","initialValue","DerivedRef","transformFn","otherRefs","ref","MAX_SOCKET_MESSAGE_SIZE","makeIdFactory","userToTreeNode","user","installBackgroundTabSpy","inBackgroundSince","CommentsApiError","createCommentsApi","roomId","fetchClientApi","fetchCommentsApi","getThreads","query","getThread","threadId","createThread","metadata","commentId","deleteThread","editThreadMetadata","createComment","editComment","deleteComment2","addReaction2","emoji","removeReaction2","MARK_INBOX_NOTIFICATIONS_AS_READ_BATCH_DELAY2","createRoom","config","initialPresence","initialStorage","uninstallBgTabSpy","getStorageStatus","managedSocket","doNotBatchUpdates","cb","batchUpdates","lastTokenKey","onStatusDidChange","newStatus","tokenKey","eventHub","notifySelfChanged","_connectionLossTimerId","_hasLostConnection","handleConnectionLossEvent","onDidConnect","_getStorage$","refreshStorage","flushNowOrSoon","onDidDisconnect","handleServerMessage","getConnectionId","activeBatch","addToUndoStack","dispatchOps","options2","streamFetch","httpPostToRoom","createTextMention","mentionId","deleteTextMention","reportTextEditor","rootKey","sendMessages","messages","serializedPayload","nonce","resp","staticSession","dynamicSession","myPresence","_lastSelf","batchedUpdatesWrapper","currSelf","selfAsTreeNode","me","createOrUpdateRootFromMessage","updateRoot","stackSizeBefore","applyOps","_addToRealUndoStack","historyOps","onHistoryChange","othersUpdates","others","updates2","notifyStorageStatus","rawOps","output","createdNodeIds","applyOpResult","applyOp","parentNode","updatePresence","oldValues","overrideValue","onUpdatePresenceMessage","oldUser","newUser","onUserLeftMessage","onRoomStateMessage","canUndo","canRedo","onUserJoinedMessage","parseServerMessage","parseServerMessages","text","applyAndSendOps","offlineOps","userJoinedUpdate","othersPresenceUpdate","u","event2","processInitialStorage","applyResult","storageOps","elapsedMillis","messagesToFlush","serializeBuffer","updateYDoc","update","guid","clientMsg","broadcastEvent","storageOperations","_resolveStoragePromise","unacknowledgedOps","streamStorage","startLoadingStorage","getStorageSnapshot","getStorage","fetchYDoc","vector","m","undo","redo","returnValue","currentBatch","pauseHistory","resumeHistory","_lastStorageStatus","storageStatus","isPresenceReady","waitUntilPresenceReady","unsub1","unsub2","isStorageReady","waitUntilStorageReady","others_forDevTools","other","commentsApi","fetchNotificationsJson","getRoomNotificationSettings","updateRoomNotificationSettings","settings","makeClassicSubscribeFn","subscribeToLiveStructureDeeply","relatedUpdates","subscribeToLiveStructureShallowly","isRoomEventName","internalEvent","storageCallback","makeAuthDelegateForRoom","makeCreateSocketDelegateForRoom","WebSocketPolyfill","ws","createClientStore","store","optimisticUpdatesEventSource","deleteKeyImmutable","_id","inboxNotification","existingThread","compareThreads","threads","inboxNotifications","deletedThreads","deletedInboxNotifications","queryKey","applyThreadUpdates","applyNotificationsUpdates","optimisticUpdate","queryState","record","_toDelete","rest","thread1","thread2","existingThreads","updatedThreads","existingInboxNotifications","updatedInboxNotifications","existingNotification","compareInboxNotifications","inboxNotificationA","inboxNotificationB","MIN_THROTTLE","MAX_THROTTLE","DEFAULT_THROTTLE","MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT","MIN_LOST_CONNECTION_TIMEOUT","RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT","MAX_LOST_CONNECTION_TIMEOUT","DEFAULT_LOST_CONNECTION_TIMEOUT","RESOLVE_USERS_BATCH_DELAY","RESOLVE_ROOMS_INFO_BATCH_DELAY","getBaseUrl","createClient","clientOptions","throttleDelay","getThrottle","lostConnectionTimeout","getLostConnectionTimeout","backgroundKeepAliveTimeout","getBackgroundKeepAliveTimeout","roomsById","teardownRoom","room","leaseRoom","leave","enterRoom","existing","newRoom","newRoomDetails","getRoom","logout","cacheStore","resolveUsers","warnIfNoResolveUsers","createDevelopmentWarning","usersStore","batchedUserIds","userIds","users","resolveRoomsInfo","warnIfNoResolveRoomsInfo","roomsInfoStore","batchedRoomIds","roomIds","roomsInfo","checkBounds","option","min","max","recommendedMin","condition","htmlEscapables","entity","markdownEscapables","makePoller","poll","schedule","interval","scheduleRemaining","remaining","restart","stop","resume","shallowArray","xs","ys","shallowObj","objA","objB","keysA","shallow","a","b","isArrayA","isArrayB","require$$0","h","l","p","q","d","f","r","t","useSyncExternalStoreShim_production_min","shimModule","require$$1","v","w","withSelector_production_min","withSelectorModule","ClientSideSuspense","props","mounted","setMounted","React.useState","React.useEffect","React.createElement","React.Suspense","MAX_ERROR_RETRY_COUNT","ERROR_RETRY_INTERVAL","retryError","action","retryCount","timeout","useLatest","useRef","useEffect2","useInitial","useReducer","useInitialUnlessFunction","latestValue","frozenValue","useCallback","ClientContext","createContext","useEnsureNoLiveblocksProvider","useClientOrNull","useContext","useClient","LiveblocksProviderWithClient","React2","LiveblocksProvider","client","useMemo","use","noop2","identity","useSyncExternalStore2","s","gs","gss","useSyncExternalStoreWithSelector2","STABLE_EMPTY_LIST","POLLING_INTERVAL2","alwaysEmptyList","alwaysNull","selectorFor_useOthersConnectionIds","makeMutationContext","cannotUseUntil","needsPresence","needsStorage","mutableRoot","handleApiError","detailedMessage","console2","_extras2","getExtrasForClient2","extras","makeExtrasForClient2","kInternal2","DEFAULT_DEDUPING_INTERVAL","lastRequestedAtByRoom","requestsByQuery","requestStatusByRoom","subscribersByQuery","poller","makePoller2","refreshThreadsAndNotifications","requests","getThreadsUpdates","incrementQuerySubscribers","subscribers2","totalSubscribers","subscribers3","since","getThreadsAndInboxNotifications","existingRequest","request","lastRequestedAt","getInboxNotificationSettings","commentsErrorEventSource","onMutationFailure","innerError","optimisticUpdateId","createPublicError","RoomContext","React4.createContext","RoomProvider","React4.useState","stableEnterRoom","React4.useCallback","rv","origLeave","React4.createElement","RoomProviderInner","frozenProps","setRoomLeavePair","React4.useEffect","handleCommentEvent","handleIsOnline","room2","useRoom","useRoomOrNull","useHistory","useCanUndo","useCanRedo","useSelf","maybeSelector","isEqual","getSnapshot","selector","wrappedSelector","getServerSnapshot","useOthers","useOthersMapped","itemSelector","itemIsEqual","wrappedIsEqual","eq","atuple","btuple","useOthersConnectionIds","NOT_FOUND","useOther","other2","other3","prev","curr","useMutableStorageRoot","useStorage","rootOrNull","rootOrNull2","onStoreChange","useMutation","deps","React4.useMemo","ensureNotServerSide","useSuspendUntilPresenceReady","useSelfSuspense","useOthersSuspense","useOthersConnectionIdsSuspense","useOthersMappedSuspense","useOtherSuspense","useSuspendUntilStorageReady","useStorageSuspense","React4.useContext","_RoomProvider","_useRoom","_useMutation","_useOthersMappedSuspense","_useOtherSuspense","_useOthersSuspense","_useStorageSuspense","_useSelfSuspense","Loading","jsx","styles","Room","roomID"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}